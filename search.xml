<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Jdon Framework]]></title>
    <url>%2F2017%2F01%2F01%2F06_tech_frame%2F064_project_case%2F0641_ddd%2Fjdon%2Fjdon_framework%2F</url>
    <content type="text"><![CDATA[开源项目：Jdon Framework下载 文档 演示 jdon英文 Github项目 项目新闻：2017-06 增加了类似erLang/akka的Actor并发模型的账户转账测试代码和多核并发测试代码，验证Jdon框架支持无锁并发和内存事务2015-05-06 Jdon框架研发思考2014-01-16 Jdonframework PPT进入SlideShare 2013前Top 1%2013-09-29 6.6.8 CQRS Command/Event异步并发输入输出。 Jdon Framework是一个实施DDD+CQRS+EventSourcing架构的Java reactive开源框架，能够快速地将领域驱动设计(DDD)落地为异步、高并发、高吞吐量的Java应用系统 。]]></content>
      <categories>
        <category>06_tech_frame</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>CQRS</tag>
        <tag>EventSourcing</tag>
        <tag>Java Reactive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络]]></title>
    <url>%2F2010%2F09%2F01%2F01_software_engineering%2F013_network%2Findex%2F</url>
    <content type="text"><![CDATA[第1章 概述第2章 物理层第3章 数据链路层第4章 网络层第5章 运输层第6章 应用层第7章 网络安全第8章 因特网上的音频/视频服务第9章 无线网络第10章 下一代因特网]]></content>
      <categories>
        <category>01_software_engineering</category>
        <category>013_network</category>
      </categories>
      <tags>
        <tag>Software Engineering</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理]]></title>
    <url>%2F2010%2F09%2F01%2F01_software_engineering%2F011_computer_principle%2Findex%2F</url>
    <content type="text"><![CDATA[第1篇 概论第1章 计算机系统概论1.1 计算机系统简介1.2 计算机的基本组成 控制器，运算器，存储器，输入设备，输出设备。 1.3 计算机硬件的主要技术指标 CPU的字长、时钟主频、运算速度、容量与可靠性。 第2章 计算机的发展及应用2.1 计算机的发展史2.2 计算机的应用2.3 计算机的展望 第2篇 计算机系统的硬件结构 第3章 系统总线3.1 总线的基本概念3.2 总线的分类3.3 总线特性及性能指标3.4 总线结构3.5 总线控制第4章 存储器4.1 概述4.2 主存储器4.3 高速缓冲存储器4.4 辅助存储器第5章 输入输出系统5.1 概述5.2 I/O设备5.3 I/O接口5.4 程序查询方式5.5 程序中断方式5.6 DMA方式附录5A ASCⅡ码附录5B BCD码附录5C 奇偶校检码 第3篇 中央处理器第6章 计算机的运算方法6.1 无符号数和有符号数6.2 数的定点表示和浮点表示6.3 定点运算6.4 浮点四则运算6.5 算术逻辑单元附录6A 各种进位制附录6B 阵列乘法器和阵列除法器附录6C 7418l逻辑电路第7章 指令系统7.1 机器指令7.2 操作数类型和操作类型7.3 寻址方式7.4 指令格式举例7.5 RISC技术第8章 CPU的结构和功能8.1 CPU的结构8.2 指令周期8.3 指令流水8.4 中断系统 第4篇 控制单元第9章 控制单元的功能9.1 微操作命令的分析9.2 控制单元的功能第10章 控制单元的设计10.1 组合逻辑设计10.2 微程序设计]]></content>
      <categories>
        <category>01_software_engineering</category>
        <category>011_computer_principle</category>
      </categories>
      <tags>
        <tag>Software Engineering</tag>
        <tag>Computer Principle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2010%2F09%2F01%2F01_software_engineering%2F014_data_structure%2Findex%2F</url>
    <content type="text"><![CDATA[第1章 绪论1.1 什么是数据结构1.2 基本概念和术语1.3 抽象数据类型的表现与实现1.4 算法和算法分析第2章 线性表2.1 线性表的类型定义2.2 线性表的顺序表示和实现2.3 线性表的链式表示和实现2.4 一元多项式的表示及相加第3章 栈和队列3.1 栈3.2 栈的应有和举例3.3 栈与递归的实现3.4 队列3.5 离散事件模拟第4章 串4.1 串类型的定义4.2 串的表示和实现4.3 串的模式匹配算法4.4 串操作应用举例第5章 数组和广义表5.1 数组的定义5.2 数组的顺序表现和实现5.3 矩阵的压缩存储5.4 广义表的定义5.5 广义表的储存结构5.6 m元多项式的表示5.7 广义表的递归算法第6章 树和二叉树6.1 树的定义和基本术语6.2 二叉树6.2.1 二叉树的定义6.2.2 二叉树的性质6.2.3 二叉树的存储结构6.3 遍历二叉树和线索二叉树6.3.1 遍历二叉树6.3.2 线索二叉树6.4 树和森林6.4.1 树的存储结构6.4.2 森林与二叉树的转换6.4.3 树和森林的遍历6.5 树与等价问题6.6 赫夫曼树及其应用### 6.6.1 最优二叉树(赫夫曼树)6.6.2 赫夫曼编码6.7 回溯法与树的遍历6.8 树的计数第7章 图7.1 图的定义和术语7.2 图的存储结构7.2.1 数组表示法7.2.2 邻接表7.2.3 十字链表7.2.4 邻接多重表7.3 图的遍历7.3.1 深度优先搜索7.3.2 广度优先搜索7.4 图的连通性问题7.4.1 无向图的连通分量和生成树7.4.2 有向图的强连通分量7.4.3 最小生成树7.4.4 关节点和重连通分量7.5 有向无环图及其应用7.5.1 拓扑排序7.5.2 关键路径7.6 最短路径7.6.1 从某个源点到其余各顶点的最短路径7.6.2 每一对顶点之间的最短路径第8章 动态存储管理8.1 概述8.2 可利用空间表及分配方法8.3 边界标识法8.3.1 可利用空间表的结构8.3.2 分配算法8.3.3 回收算法8.4 伙伴系统8.4.1 可利用空间表的结构8.4.2 分配算法8.4.3 回收算法8.5 无用单元收集8.6 存储紧缩第9章 查找9.1 静态查找表9.1.1 顺序表的查找9.1.2 有序表的查找9.1.3 静态树表的查找9.1.4 索引顺序表的查找9.2 动态查找表9.2.1 二叉排序树和平衡二叉树9.2.2 B树和B+树9.2.3 键树9.3 哈希表9.3.1 什么是哈希表9.3.2 哈希函数的构造方法9.3.3 处理冲突的方法9.3.4 哈希表的查找及其分析第10章 内部排序10.1 概述10.2 插入排序10.2.1 直接插入排序10.2.2 其他插入排序10.2.3 希尔排序10.3 快速排序10.4 选择排序10.4.1 简单选择排序10.4.2 树形选择排序10.4.3 堆排序10.5 归并排序10.6 基数排序10.6.1 多关键字的排序10.6.2 链式基数排序10.7 各种内部排序方法的比较讨论第11章 外部排序11.1 外存信息的存取11.2 外部排序的方法11.3 多路平衡归并的实现11.4 置换一选择排序11.5 最佳归并树第12章 文件12.1 有关文件的基本概念12.2 顺序文件12.3 索引文件12.4 ISAM文件和VSAM文件12.4.1 ISAM文件12.4.2 VSAM文件12.5 直接存取文件(散列文件)12.6 多关键字文件12.6.1 多重表文件12.6.2 倒排文件]]></content>
      <categories>
        <category>01_software_engineering</category>
        <category>014_data_structure</category>
      </categories>
      <tags>
        <tag>Software Engineering</tag>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法设计与分析]]></title>
    <url>%2F2010%2F09%2F01%2F01_software_engineering%2F015_algorithm%2Findex%2F</url>
    <content type="text"><![CDATA[第1章 算法概述1.1 算法与程序1.2 算法复杂性分析第2章 递归与分治策略2.1 递归的概念2.2 分治法的基本思想2.3 二分搜索技术2.4 大整数的乘法2.5 Strassen矩阵乘法2.6 棋盘覆盖2.7 合并排序2.8 快速排序2.9 线性时间选择2.10 最接近点对问题2.11 循环赛日程表第3章 动态规划3.1 矩阵连乘问题3.2 动态规划算法的基本要素3.3 最长公共子序列3.4 最大子段和3.5 凸多边形最优三角剖分3.6 多边形游戏3.7 图像压缩3.8 电路布线3.9 流水作业调度3.10 0-1背包问题3.11 最优二叉搜索树3.12 动态规划加速原理第4章 贪心算法第5章 回溯法第6章 分支限界法第7章 随机化算法第8章 线性规划与网络流第9章 NP完全性理论与近似算法]]></content>
      <categories>
        <category>01_software_engineering</category>
        <category>015_algorithm</category>
      </categories>
      <tags>
        <tag>Software Engineering</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统]]></title>
    <url>%2F2010%2F09%2F01%2F01_software_engineering%2F012_operating_system%2Findex%2F</url>
    <content type="text"><![CDATA[第一章 操作系统引论1.1 操作系统的目标和作用1.2 操作系统的发展过程1.3 操作系统的基本特性1.4 操作系统的主要功能1.5 OS结构设计第二章 进程管理2.1 进程的基本概念2.2 进程控制2.3 进程同步2.4 经典进程的同步问题2.5 进程通信2.6 线程第三章 处理机调度与死锁3.1 处理机调度的层次3.2 调度队列模型和调度准则3.3 调度算法3.4 实时调度3.5 产生死锁的原因和必要条件3.6 预防死锁的方法3.7 死锁的检测与解除第四章 存储器管理4.1 存储器的层次结构4.2 程序的装入和链接4.3 连续分配方式4.4 基本分页存储管理方式4.5 基本分段存储管理方式4.6 虚拟存储器的基本概念4.7 请求分页存储管理方式4.8 页面置换算法4.9 请求分段存储管理方式第五章 设备管理5.1 I/O系统5.2 I/0控制方式5.3 缓冲管理5.4 I/O软件5.5 设备分配5.6 磁盘存储器的管理第六章 文件管理6.1 文件和文件系统6.2 文件的逻辑结构6.3 外存分配方式6.4 目录管理6.5 文件存储空间的管理6.6 文件共享与文件保护6.7 数据一致性控制第七章 操作系统接口7.1 联机用户接口7.2 Shell命令语言7.3 系统调用7.4 UNIX系统调用7.5 图形用户接口第八章 网络操作系统8.1 计算机网络概述8.2 网络体系结构8.3 Internet与Intranet8.4 客户，服务器模式8.5 网络操作系统的功能8.6 网络操作系统提供的服务第九章 系统安全性9.1 系统安全的基本概念9.2 数据加密技术9.3 认证技术9.4 访问控制技术9.5 计算机病毒第十章 UNIX系统内核结构10.1 UNIX系统概述10.2 进程的描述和控制10.3 进程的同步与通信10.4 存储器管理10.5 设备管理10.6 文件管理]]></content>
      <categories>
        <category>01_software_engineering</category>
        <category>012_operating_system</category>
      </categories>
      <tags>
        <tag>Software Engineering</tag>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM OJ集锦]]></title>
    <url>%2F2010%2F09%2F01%2F01_software_engineering%2F015_algorithm%2F0151_acm%2Facm_oj_collection%2F</url>
    <content type="text"><![CDATA[ACM OJ Collection（排名不分先后）：中国：(China)华东地区：浙江： 杭州电子科技大学(HDU)：http://acm.hdu.edu.cn/ 浙江大学（ZJU）：http://acm.zju.edu.cn/ 浙江工业大学（ZJUT）：http://acm.zjut.edu.cn/ 浙江师范大学（ZJNU）：http://acm.zjnu.cn/ 浙江工商（ZJGSU）：http://acm.zjgsu.edu.cn/ 宁波理工（NIT）：http://acm.nit.net.cn/ 上海： 华东师范大学（ECNU）：http://acm.cs.ecnu.edu.cn/ 华东理工大学（ECUST）：http://acm.ecust.edu.cn/ 同济大学（TJU）：http://acm.tongji.edu.cn/ 江苏： 南京航空航天大学： http://acm.nuaa.edu.cn/ 福建： 福州大学（FZU）：http://acm.fzu.edu.cn/ 厦门大学（XMU）：http://acm.xmu.edu.cn/ 福建师范大学（FJNU）：http://acm.fjnu.edu.cn/ 安徽： 中国科技大学（USTC）：http://acm.ustc.edu.cn/ 华北地区：北京： 北京交大（BJTU）：http://acm.bjtu.edu.cn/ 北京大学（PKU）：http://acm.pku.edu.cn/ 天津： 南开大学（NAIKAI）：http://acm.nankai.edu.cn/ 天津大学（TJU）：http://acm.tju.edu.cn/toj/ 东北地区：黑龙江： 哈尔滨工程大学（HRBEU）：http://acm.hrbeu.edu.cn/ 华南地区：广东： 中山大学（ZSU）：http://acm.zsu.edu.cn/ 西南地区：四川： 西南民大（SWUN）：http://acm.swun.edu.cn/ 华中地区：湖北： 华中科技大学（HUST）：http://acm.hust.edu.cn/JudgeOnline/ 武汉大学（WHU）：http://acm.whu.edu.cn/ 港澳台地区：香港： 香港大学(HKOI)：http://judge.hkoi.org/ 俄罗斯：(Russia) 乌拉尔大学（URAL）：http://acm.timus.ru/ 萨拉托夫大学（SGU）：http://acm.sgu.ru/ (vallod) ：http://acm.uva.es/ EL Judge(MIPT):：http://acm.mipt.ru/judge/problems.pl 西班牙：(Spanish) 瓦拉杜利德大学（UVA）：http://acm.uva.es/ 美国：(America) USACO: http://train.usaco.org/usacogate 波兰：(Poland) SPOJ：http://www.spoj.pl/ 吉尔吉斯斯坦:：(Kirgizstan) KRSU: http://www.olymp.krsu.edu.kg/GeneralProblemset.aspx 中国各大高校BBS: http://acm.hdu.edu.cn/forum/（杭电） http://www.hdubbs.com/（杭电） http://www.freecity.cn/（浙大） http://bbs.freecity.cn/(浙大) Others： Topcoder：http://www.topcoder.com/tc ACM-ICPC：http://icpc.baylor.edu/icpc/ 美国信息学奥林匹克竞赛官方网站：http://www.usaco.org/ 全美计算机奥林匹克竞赛：http://ace.delos.com/usacogate 信息学初学者之家：http://oibh.ioiforum.org/ 中国教育曙光网：http://www.chinaschool.org/aosai/ 福建信息学奥林匹克：http://www.cfcs.com.cn/fjas/index.htm IOI：http://olympiads.win.tue.nl/ioi/ 高效信息学在线判题系统（VIJOS）：http://www.vijos.cn/ ACM的例程和测试数据：http://www.karrels.org/Ed/ACM/ ACM社区：http://www.608088.com/]]></content>
      <categories>
        <category>01_software_engineering</category>
        <category>015_algorithm</category>
        <category>0151_acm</category>
      </categories>
      <tags>
        <tag>Software Engineering</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkedList详细介绍(源码解析)和使用示例]]></title>
    <url>%2F2010%2F09%2F01%2F02_code_language%2F022_java%2F0223_set_utils%2Flinked_list%2FLinkedList%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D(%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90)%E5%92%8C%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[LinkedList详细介绍(源码解析)和使用示例http://www.cnblogs.com/skywang12345/p/3308807.html]]></content>
      <categories>
        <category>02_code_language</category>
        <category>022_java</category>
        <category>0223_set_utils</category>
      </categories>
      <tags>
        <tag>Code Language</tag>
        <tag>Java</tag>
        <tag>Set Utils</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java网络教程之Socket]]></title>
    <url>%2F2010%2F09%2F01%2F02_code_language%2F022_java%2F0225_net%2Fsocket%2FJava%E7%BD%91%E7%BB%9C%E6%95%99%E7%A8%8B%E4%B9%8BSocket%2F</url>
    <content type="text"><![CDATA[Java网络教程之Socket原文地址 译者：贾毅 当我们想要在Java中使用TCP/IP通过网络连接到服务器时，就需要创建java.net.Socket对象并连接到服务器。假如希望使用Java NIO，也可以创建Java NIO中的SocketChannel对象。 创建**Socket** 下面的示例代码是连接到IP地址为78.64.84.171服务器上的80端口，这台服务器就是我们的Web服务器（www.jenkov.com），而80端口就是Web服务端口。 Socket socket = new Socket(“78.46.84.171”, 80); 我们也可以像如下示例中使用域名代替IP地址： Socket socket = new Socket(“jenkov.com”, 80); Socket**发送数据** 要通过Socket发送数据，我们需要获取Socket的输出流（OutputStream），示例代码如下： Socket socket = new Socket(“jenkov.com”, 80);OutputStream out = socket.getOutputStream();out.write(“some data”.getBytes());out.flush();out.close();socket.close(); 代码非常简单，但是想要通过网络将数据发送到服务器端，一定不要忘记调用flush()方法。操作系统底层的TCP/IP实现会先将数据放入一个更大的数据缓存块中，而缓存块的大小是与TCP/IP的数据包大小相适应的。（译者注：调用flush()方法只是将数据写入操作系统缓存中，并不保证数据会立即发送） Socket**读取数据** 从Socket中读取数据，我们就需要获取Socket的输入流（InputStream），代码如下： Socket socket = new Socket(“jenkov.com”, 80);InputStream in = socket.getInputStream();int data = in.read();//… read more data…in.close();socket.close(); 代码也并不复杂，但需要注意的是，从Socket的输入流中读取数据并不能读取文件那样，一直调用read()方法直到返回-1为止，因为对Socket而言，只有当服务端关闭连接时，Socket的输入流才会返回-1，而是事实上服务器并不会不停地关闭连接。假设我们想要通过一个连接发送多个请求，那么在这种情况下关闭连接就显得非常愚蠢。 因此，从Socket的输入流中读取数据时我们必须要知道需要读取的字节数，这可以通过让服务器在数据中告知发送了多少字节来实现，也可以采用在数据末尾设置特殊字符标记的方式连实现。 关闭**Socket** 当使用完Socket后我们必须将Socket关闭，断开与服务器之间的连接。关闭Socket只需要调用Socket.close()方法即可，代码如下： Socket socket = new Socket(“jenkov.com”, 80); socket.close(); http://ifeve.com/java-socket/]]></content>
      <categories>
        <category>02_code_language</category>
        <category>022_java</category>
        <category>0225_net</category>
      </categories>
      <tags>
        <tag>Code Language</tag>
        <tag>Java</tag>
        <tag>NET</tag>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java网络编程：UDP DatagramSocket]]></title>
    <url>%2F2010%2F09%2F01%2F02_code_language%2F022_java%2F0225_net%2Fsocket%2FJava%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%9AUDP%20DatagramSocket%2F</url>
    <content type="text"><![CDATA[Java网络编程：UDP DatagramSocket原文地址 DatagramSocket类是java通过UDP通信的途径。UDP仍位于IP层的上面。 你可以用DatagramSocket类发送和接收UDP数据包。 UDP 和TCP UDP工作方式和TCP有点不同。当你通过TCP发送数据时，你先要创建连接。一旦TCP连接建立了，TCP会保证你的数据传递到对端，否则它将告诉你已发生的错误。 仅仅用UDP来发送数据包（datagrams）到网络间的某个IP地址。你不能保证数据会不会到达。你也不能保证UDP数据包到达接收方的指令。这意味着UDP比TCP有更少的协议开销（无完整检查流）。 当数据传输过程中不在乎数据包是否丢失时，UDP就比较适合这样的数据传输。比如，网上的电视信号的传输。你希望信号到达客户端时尽可能地接近直播。因此，如果丢失一两个画面，你一点都不在乎。你不希望直播延迟，值想确保所有的画面显示在客户端。你宁可跳过丢失的画面，希望一直看到最新的画面。 这种情况也会发生在网上摄像机直播节目中。谁会关心过去发生的什么，你只想显示当前的画面。你不希望比实际情况慢30s结束，只因为你想看到摄像机显示给观众的所有画面。这跟摄像机录像有点不同。从摄像机录制画面到磁盘，你不希望丢失一个画面。你可能还希望有点延迟，如果有重大的情况发生，就不需要倒回去检查画面。 通过DatagramSocket发送数据通过Java的DatagramSocket类发送数据，首先需要创建DatagramPacket。如下： buffer = new byte[65508];InetAddress address = new DatagramPacket(buffer, buffer.length, address,9000); 字节缓冲块（字节数组）就是UDP数据包中用来发送的数据。缓冲块上限长度为65508字节，是单一UDP数据包发送的最大的数据量。 数据包构造函数的长度就是缓存块中用于发送的数据的长度。所有多于最大容量的数据都会被忽略。 包含节点（例如服务器）地址的InetAddress实例携带节点（如服务器）的地址发送的UDP数据包。InetAddress类表示一个ip地址（网络地址）。getByName()方法返回带有一个InetAddress实例，该实例带有匹配主机名的ip地址。 端口参数是UDP端口服务器用来接收正在监听的数据。UDP端口和TCP端口是不一样的。一台电脑同时有不同的进程监听UDP和TCP 80端口。 为了发送数据包，你需要创建DatagramSocket来发送数据。如下： DatagramSocketdatagramSocket = new DatagramSocket(); 调用send()方法发送数据，像这样： datagramSocket.send(packet); 完整示例： DatagramSocketdatagramSocket = new DatagramSocket();byte [] buffer = “0123456789”.getBytes();InetAddressreceiverAddress = InetAddress.getLocalHost();DataframPacket packet =newDatagramPacket( buffer, buffer.length, receiverAddress, 80);datagramSocket.send(packet); 从DatagramSocket获取数据从DataframSocket获取数据时，首先创建DataframPacket,然后通过DatagramSocket类的receive()方法接收数据。例如：DatagramSocketdatagramSocket = new DatagramSocket(80);yte [] buffer = new byte [10];DatagramPacket packet = new DatagramPacket(buffer, buffer.length);datagramSocket.receive(packet); 注意DatagramSocket是如何通过传递参数80到它的构造器初始化的。这个参数是UDP端口的DatagramSocket用来接收UDP数据包的。像之前提到的，TCP和UDP端口是不一样的，也不重叠。你可以有俩个不同的进程同时在端口80监听TCP和UDP，没有任何冲突。 第二，字节缓存块和DatagramPacket创建了。注意DatagramPacket是没有关于节点如何发送数据的信息的，当创建一个方数据的DatagramPacket时，它会直到这个信息。这就是为什么我们会用DatagramPacket接收数据而不是发送数据。因此没有目标地址是必须的。 最后，调用DatagramSocket的receive()方法。直到数据包接收到为止，这个方法都是阻塞的。 接收的数据位于DatagramPacket的字节缓冲块。缓冲块可以通过调用getData()获得： byte [] buffer = packet.getData(); 缓冲块接收了多少的数据需要你去找出来。你用的协议应该定义每个UDP包发多少数据，活着定义一个你能找到的数据结束标记。一个真正的服务端程序可能会在一个loop中调用receive()方法，传送所有接收到的DatagramPacket到工作的线程池中，就像TCP服务器处理请求连接一样（查看Java Multithreaded Servers获取更多详情） http://ifeve.com/java-udp-datagramsocket/]]></content>
      <categories>
        <category>02_code_language</category>
        <category>022_java</category>
        <category>0225_net</category>
      </categories>
      <tags>
        <tag>Code Language</tag>
        <tag>Java</tag>
        <tag>NET</tag>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CGLIB(Code Generation Library)详解]]></title>
    <url>%2F2010%2F09%2F01%2F02_code_language%2F022_java%2F0221_java_base%2Fdynamic_proxy%2Fcglib%2FCGLIB(Code%20Generation%20Library)%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[CGLIB(Code Generation Library)详解http://blog.csdn.net/danchu/article/details/70238002]]></content>
      <categories>
        <category>02_code_language</category>
        <category>022_java</category>
        <category>0221_java_base</category>
      </categories>
      <tags>
        <tag>Code Language</tag>
        <tag>Java</tag>
        <tag>Java Base</tag>
        <tag>CGLIB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaNIO系列教程]]></title>
    <url>%2F2010%2F09%2F01%2F02_code_language%2F022_java%2F0224_io%2Fnio%2FJavaNIO%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[JavaNIO系列教程http://ifeve.com/java-nio-all/]]></content>
      <categories>
        <category>02_code_language</category>
        <category>022_java</category>
        <category>0224_io</category>
      </categories>
      <tags>
        <tag>Code Language</tag>
        <tag>Java</tag>
        <tag>IO</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP十个入门问题]]></title>
    <url>%2F2010%2F09%2F01%2F02_code_language%2F022_java%2F0225_net%2Ftcp_ip%2FTCP%20IP%E5%8D%81%E4%B8%AA%E5%85%A5%E9%97%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[TCP IP十个入门问题 本文整理了一些TCP/IP协议簇中需要必知必会的十大问题，既是面试高频问题，又是程序员必备基础素养。 1、TCP/IP模型 TCP/IP协议模型（Transmission Control Protocol/Internet Protocol），包含了一系列构成互联网基础的网络协议，是Internet的核心协议。 基于TCP/IP的参考模型将协议分成四个层次，它们分别是链路层、网络层、传输层和应用层。下图表示TCP/IP模型与OSI模型各层的对照关系。 TCP/IP协议族按照层次由上到下，层层包装。最上面的是应用层，这里面有http，ftp,等等我们熟悉的协议。而第二层则是传输层，著名的TCP和UDP协议就在这个层次。第三层是网络层，IP协议就在这里，它负责对数据加上IP地址和其他的数据以确定传输的目标。第四层是数据链路层，这个层次为待传送的数据加入一个以太网协议头，并进行CRC编码，为最后的数据传输做准备。 上图清楚地表示了TCP/IP协议中每个层的作用，而TCP/IP协议通信的过程其实就对应着数据入栈与出栈的过程。入栈的过程，数据发送方每层不断地封装首部与尾部，添加一些传输的信息，确保能传输到目的地。出栈的过程，数据接收方每层不断地拆除首部与尾部，得到最终传输的数据。 上图以HTTP协议为例，具体说明。 2、数据链路层 物理层负责0、1比特流与物理设备电压高低、光的闪灭之间的互换。 数据链路层负责将0、1序列划分为数据帧从一个节点传输到临近的另一个节点,这些节点是通过MAC来唯一标识的(MAC,物理地址，一个主机会有一个MAC地址)。 封装成帧: 把网络层数据报加头和尾，封装成帧,帧头中包括源MAC地址和目的MAC地址。 透明传输:零比特填充、转义字符。 可靠传输: 在出错率很低的链路上很少用，但是无线链路WLAN会保证可靠传输。 差错检测(CRC):接收者检测错误,如果发现差错，丢弃该帧。 3、网络层 1.IP协议 IP协议是TCP/IP协议的核心，所有的TCP，UDP，IMCP，IGMP的数据都以IP数据格式传输。要注意的是，IP不是可靠的协议，这是说，IP协议没有提供一种数据未传达以后的处理机制，这被认为是上层协议：TCP或UDP要做的事情。 1.1 IP地址 在数据链路层中我们一般通过MAC地址来识别不同的节点，而在IP层我们也要有一个类似的地址标识，这就是IP地址。 32位IP地址分为网络位和地址位，这样做可以减少路由器中路由表记录的数目，有了网络地址，就可以限定拥有相同网络地址的终端都在同一个范围内，那么路由表只需要维护一条这个网络地址的方向，就可以找到相应的这些终端了。 A类IP地址: 0.0.0.0~127.255.255.255 B类IP地址:128.0.0.0~191.255.255.255 C类IP地址:192.0.0.0~239.255.255.255 1.2 IP协议头 这里只介绍:八位的TTL字段。这个字段规定该数据包在穿过多少个路由之后才会被抛弃。某个IP数据包每穿过一个路由器，该数据包的TTL数值就会减少1，当该数据包的TTL成为零，它就会被自动抛弃。 这个字段的最大值也就是255，也就是说一个协议包也就在路由器里面穿行255次就会被抛弃了，根据系统的不同，这个数字也不一样，一般是32或者是64。 2.ARP及RARP协议 ARP 是根据IP地址获取MAC地址的一种协议。 ARP（地址解析）协议是一种解析协议，本来主机是完全不知道这个IP对应的是哪个主机的哪个接口，当主机要发送一个IP包的时候，会首先查一下自己的ARP高速缓存（就是一个IP-MAC地址对应表缓存）。 如果查询的IP－MAC值对不存在，那么主机就向网络发送一个ARP协议广播包，这个广播包里面就有待查询的IP地址，而直接收到这份广播的包的所有主机都会查询自己的IP地址，如果收到广播包的某一个主机发现自己符合条件，那么就准备好一个包含自己的MAC地址的ARP包传送给发送ARP广播的主机。 而广播主机拿到ARP包后会更新自己的ARP缓存（就是存放IP-MAC对应表的地方）。发送广播的主机就会用新的ARP缓存数据准备好数据链路层的的数据包发送工作。 RARP协议的工作与此相反，不做赘述。 3. ICMP协议 IP协议并不是一个可靠的协议，它不保证数据被送达，那么，自然的，保证数据送达的工作应该由其他的模块来完成。其中一个重要的模块就是ICMP(网络控制报文)协议。ICMP不是高层协议，而是IP层的协议。 当传送IP数据包发生错误。比如主机不可达，路由不可达等等，ICMP协议将会把错误信息封包，然后传送回给主机。给主机一个处理错误的机会，这 也就是为什么说建立在IP层以上的协议是可能做到安全的原因。 4、ping ping可以说是ICMP的最著名的应用，是TCP/IP协议的一部分。利用“ping”命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。 例如：当我们某一个网站上不去的时候。通常会ping一下这个网站。ping会回显出一些有用的信息。一般的信息如下: ping这个单词源自声纳定位，而这个程序的作用也确实如此，它利用ICMP协议包来侦测另一个主机是否可达。原理是用类型码为0的ICMP发请 求，受到请求的主机则用类型码为8的ICMP回应。 ping程序来计算间隔时间，并计算有多少个包被送达。用户就可以判断网络大致的情况。我们可以看到， ping给出来了传送的时间和TTL的数据。 5、Traceroute Traceroute是用来侦测主机到目的主机之间所经路由情况的重要工具，也是最便利的工具。 Traceroute的原理是非常非常的有意思，它收到到目的主机的IP后，首先给目的主机发送一个TTL=1的UDP数据包，而经过的第一个路由器收到这个数据包以后，就自动把TTL减1，而TTL变为0以后，路由器就把这个包给抛弃了，并同时产生 一个主机不可达的ICMP数据报给主机。主机收到这个数据报以后再发一个TTL=2的UDP数据报给目的主机，然后刺激第二个路由器给主机发ICMP数据 报。如此往复直到到达目的主机。这样，traceroute就拿到了所有的路由器IP。 6、TCP/UDP TCP/UDP都是是传输层协议，但是两者具有不同的特性，同时也具有不同的应用场景，下面以图表的形式对比分析。 面向报文 面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。 面向字节流 面向字节流的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。 关于拥塞控制，流量控制，是TCP的重点，后面讲解。 TCP和UDP协议的一些应用 什么时候应该使用TCP？ 当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 什么时候应该使用UDP？ 当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。]]></content>
      <categories>
        <category>02_code_language</category>
        <category>022_java</category>
        <category>0225_net</category>
      </categories>
      <tags>
        <tag>Code Language</tag>
        <tag>Java</tag>
        <tag>TCP/IP</tag>
        <tag>NET</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TreeMap详细介绍(源码解析)和使用示例]]></title>
    <url>%2F2010%2F09%2F01%2F02_code_language%2F022_java%2F0223_set_utils%2Ftreemap%2FTreeMap%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D(%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90)%E5%92%8C%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[TreeMap详细介绍(源码解析)和使用示例http://www.cnblogs.com/skywang12345/p/3310928.html]]></content>
      <categories>
        <category>02_code_language</category>
        <category>022_java</category>
        <category>0223_set_utils</category>
      </categories>
      <tags>
        <tag>Code Language</tag>
        <tag>Java</tag>
        <tag>Set Utils</tag>
        <tag>TreeMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap详细介绍(源码解析)和使用示例]]></title>
    <url>%2F2010%2F09%2F01%2F02_code_language%2F022_java%2F0223_set_utils%2Fhashmap%2FHashMap%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D(%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90)%E5%92%8C%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[HashMap详细介绍(源码解析)和使用示例https://www.cnblogs.com/skywang12345/p/3310835.html]]></content>
      <categories>
        <category>02_code_language</category>
        <category>022_java</category>
        <category>0223_set_utils</category>
      </categories>
      <tags>
        <tag>Code Language</tag>
        <tag>Java</tag>
        <tag>Set Utils</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AbstractQueuedSynchronizer源码解读]]></title>
    <url>%2F2010%2F09%2F01%2F02_code_language%2F022_java%2F0221_java_base%2Fabstract_queued_synchronizer%2FAbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[AbstractQueuedSynchronizer源码解读https://www.cnblogs.com/micrari/p/6937995.html]]></content>
      <categories>
        <category>02_code_language</category>
        <category>022_java</category>
        <category>0221_java_base</category>
      </categories>
      <tags>
        <tag>Code Language</tag>
        <tag>Java</tag>
        <tag>Java Base</tag>
        <tag>Abstract Queued Synchronizer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈CAS(Compare and Swap) 原理]]></title>
    <url>%2F2010%2F09%2F01%2F02_code_language%2F022_java%2F0221_java_base%2Fcompare_and_swap%2F%E6%B5%85%E8%B0%88CAS(Compare%20and%20Swap)%20%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[浅谈CAS(Compare and Swap) 原理https://www.cnblogs.com/Leo_wl/p/6899716.html]]></content>
      <categories>
        <category>02_code_language</category>
        <category>022_java</category>
        <category>0221_java_base</category>
      </categories>
      <tags>
        <tag>Code Language</tag>
        <tag>Java</tag>
        <tag>Java Base</tag>
        <tag>Compare and Swap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux写时拷贝技术(copy-on-write)]]></title>
    <url>%2F2010%2F09%2F01%2F02_code_language%2F022_java%2F0221_java_base%2Fcopy_on_write%2FLinux%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF(copy-on-write)%2F</url>
    <content type="text"><![CDATA[Linux写时拷贝技术(copy-on-write)https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html]]></content>
      <categories>
        <category>02_code_language</category>
        <category>022_java</category>
        <category>0221_java_base</category>
      </categories>
      <tags>
        <tag>Code Language</tag>
        <tag>Java</tag>
        <tag>Java Base</tag>
        <tag>Copy on Write</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CGLIB(Code Generation Library)详解]]></title>
    <url>%2F2010%2F09%2F01%2F02_code_language%2F022_java%2F0222_jvm%2Fclass_loader%2Fjava%E4%B8%AD%E7%9A%84ClassLoader%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[java中的ClassLoader详解http://blog.csdn.net/briblue/article/details/54973413]]></content>
      <categories>
        <category>02_code_language</category>
        <category>022_java</category>
        <category>0222_jvm</category>
      </categories>
      <tags>
        <tag>Code Language</tag>
        <tag>Java</tag>
        <tag>Jvm</tag>
        <tag>ClassLoader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaGC介绍]]></title>
    <url>%2F2010%2F09%2F01%2F02_code_language%2F022_java%2F0222_jvm%2Fgc%2FJavaGC%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[JavaGC介绍http://blog.csdn.net/d6619309/article/details/53358250]]></content>
      <categories>
        <category>02_code_language</category>
        <category>022_java</category>
        <category>0222_jvm</category>
      </categories>
      <tags>
        <tag>Code Language</tag>
        <tag>Java</tag>
        <tag>Jvm</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析java内存模型]]></title>
    <url>%2F2010%2F09%2F01%2F02_code_language%2F022_java%2F0222_jvm%2Fmemory_model%2F%E6%B5%85%E6%9E%90java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[浅析java内存模型https://www.cnblogs.com/lewis0077/p/5143268.html]]></content>
      <categories>
        <category>02_code_language</category>
        <category>022_java</category>
        <category>0222_jvm</category>
      </categories>
      <tags>
        <tag>Code Language</tag>
        <tag>Java</tag>
        <tag>Jvm</tag>
        <tag>Memory Model</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache-Commons包作用说明]]></title>
    <url>%2F2010%2F09%2F01%2F02_code_language%2F022_java%2F0223_set_utils%2Fapache_commons%2FApache-Commons%E5%8C%85%E4%BD%9C%E7%94%A8%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[Apache-Commons包作用说明http://blog.csdn.net/qq877507054/article/details/51395859]]></content>
      <categories>
        <category>02_code_language</category>
        <category>022_java</category>
        <category>0223_set_utils</category>
      </categories>
      <tags>
        <tag>Code Language</tag>
        <tag>Java</tag>
        <tag>Set Utils</tag>
        <tag>Apache Commons</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList详解]]></title>
    <url>%2F2010%2F09%2F01%2F02_code_language%2F022_java%2F0223_set_utils%2Farray_list%2FArrayList%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[ArrayList详解http://blog.csdn.net/u012877472/article/details/50852933]]></content>
      <categories>
        <category>02_code_language</category>
        <category>022_java</category>
        <category>0223_set_utils</category>
      </categories>
      <tags>
        <tag>Code Language</tag>
        <tag>Java</tag>
        <tag>Set Utils</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入分析ConcurrentHashMap]]></title>
    <url>%2F2010%2F09%2F01%2F02_code_language%2F022_java%2F0223_set_utils%2Fconcurrent_hashmap%2F%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90ConcurrentHashMap%2F</url>
    <content type="text"><![CDATA[深入分析ConcurrentHashMaphttp://ifeve.com/concurrenthashmap/]]></content>
      <categories>
        <category>02_code_language</category>
        <category>022_java</category>
        <category>0223_set_utils</category>
      </categories>
      <tags>
        <tag>Code Language</tag>
        <tag>Java</tag>
        <tag>Set Utils</tag>
        <tag>ConcurrentHashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中常见的数据结构的区别]]></title>
    <url>%2F2010%2F09%2F01%2F01_software_engineering%2F014_data_structure%2FJava%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Java中常见的数据结构的区别 把多个数据按照一定的存储方式,存储起来,称存储方式之为数据结构.数据的存储方式有很多,数组,队列,链表,栈,哈希表等等.不同的数据结构,性能是不一样的,比如有的插入比较快,查询比较快,但是删除比较慢.有的删除比较快,插入比较快,但是查询比较慢. 根据实际操作,合理选择即可. ArrayList和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素，但是插入数据要设计到数组元素移动等内存操作，所以索引数据快插入数据慢，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差，LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快！ 不同的数据结构在做不同操作时,性能是有差异的,在业界计算性能叫做”大O算法”,我们简单分析以下就可以了. 分析ArrayList(基于数组的列表)在做CRUD时性能如何： 1:插入:且先不考虑扩容问题,扩容其实比较好性能(创建新数组,数组元素拷贝). 2:删除:把后面的元素整体向前移动. 如果删除最后一个元素: 此时操作1次. 如果删除第一个元素 : 此时操作N次. 平均:(N+1)/2次. 3:修改:操作1次. 4:查询:如果是根据索引来查询元素,就操作1次.如果是根据元素来查询第一次/最后一次出现的位置: 若元素就在第一个位置:此时操作1次.若元素在最后一个位置:此时操作N次. 平均:(N+1)/2次. 此时发现基于数组的列表(ArrayList),在删除操作上,比较慢.在插入,修改,查询上,比较快. 简单分析LinkedList的算法性能: 1:插入操作: 单向列表:插入第一个只有1次操作. 插入最后一个:N次操作.双向列表:插入第一个/最后一个都是1次. 但是,插入到中间位置:N/2次. 2:修改操作: N/2次操作. 3:查询操作:获取第一个和最后一个,只有1次操作. 查询中间的元素:N/2次. 4:删除操作:N/2次+1次. 操作第一个和最后一个是非常快的.从性能上分析,删除/插入到中间位置操作改变上一个和下一个的引用地址相对于ArrayList的移位来说,较快. 线性表，链表，哈希表是常用的数据结构，在进行Java开发时，JDK已经为我们提供了一系列相应的类来实现基本的数据结构。这些类均在java.util包中。 List跟Set继承自Collection接口:Collection├List│├LinkedList│├ArrayList│└Vector│ └Stack└SetMap├Hashtable├HashMap└WeakHashMap Collection接口 Collection是最基本的集合接口，一个Collection代表一组Object，即Collection的元素（Elements）。一些Collection允许相同的元素而另一些不行。一些能排序而另一些不行。JavaSDK不提供直接继承自Collection的类，JavaSDK提供的类都是继承自Collection的“子接口”如List和Set。 所有实现Collection接口的类都必须提供两个标准的构造函数：无参数的构造函数用于创建一个空的Collection，有一个Collection参数的构造函数用于创建一个新的Collection，这个新的Collection与传入的Collection有相同的元素。后一个构造函数允许用户复制一个Collection。 如何遍历Collection中的每一个元素？不论Collection的实际类型如何，它都支持一个iterator()的方法，该方法返回一个迭代子，使用该迭代子即可逐一访问Collection中每一个元素。典型的用法如下： Iterator it = collection.iterator(); // 获得一个迭代子 while(it.hasNext()) { Object obj = it.next(); // 得到下一个元素 } 由Collection接口派生的两个接口是List和Set。 List接口 List是有序的Collection，使用此接口能够精确的控制每个元素插入的位置。用户能够使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素，这类似于Java的数组。和下面要提到的Set不同，List允许有相同的元素。 除了具有Collection接口必备的iterator()方法外，List还提供一个listIterator()方法，返回一个ListIterator接口，和标准的Iterator接口相比，ListIterator多了一些add()之类的方法，允许添加，删除，设定元素，还能向前或向后遍历。 实现List接口的常用类有LinkedList，ArrayList，Vector和Stack。 LinkedList类 LinkedList实现了List接口，允许null元素。此外LinkedList提供额外的get，remove，insert方法在LinkedList的首部或尾部。这些操作使LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。 注意LinkedList没有同步方法。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List： List list = Collections.synchronizedList(new LinkedList(…)); ArrayList类 ArrayList实现了可变大小的数组。它允许所有元素，包括null。ArrayList没有同步。size，isEmpty，get，set方法运行时间为常数。但是add方法开销为分摊的常数，添加n个元素需要t(n)的时间。其他的方法运行时间为线性。 每个ArrayList实例都有一个容量（Capacity），即用于存储元素的数组的大小。这个容量可随着不断添加新元素而自动增加，但是增长算法并没有定义。当需要插入大量元素时，在插入前可以调用ensureCapacity方法来增加ArrayList的容量以提高插入效率。 和LinkedList一样，ArrayList也是非同步的（unsynchronized）。 Vector类 Vector非常类似ArrayList，但是Vector是同步的。由Vector创建的Iterator，虽然和ArrayList创建的Iterator是同一接口，但是，因为Vector是同步的，当一个Iterator被创建而且正在被使用，另一个线程改变了Vector的状态（例如，添加或删除了一些元素），这时调用Iterator的方法时将抛出ConcurrentModificationException，因此必须捕获该异常。 Stack 类 Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。 Set接口 Set是一种不包含重复的元素的Collection，即任意的两个元素e1和e2都有e1.equals(e2)=false，Set最多有一个null元素。 很明显，Set的构造函数有一个约束条件，传入的Collection参数不能包含重复的元素。 请注意：必须小心操作可变对象（MutableObject）。如果一个Set中的可变元素改变了自身状态导致Object.equals(Object)=true将导致一些问题。 Map接口 请注意，Map没有继承Collection接口，Map提供key到value的映射。一个Map中不能包含相同的key，每个key只能映射一个value。Map接口提供3种集合的视图，Map的内容可以被当作一组key集合，一组value集合，或者一组key-value映射。 Hashtable类 Hashtable继承Map接口，实现一个key-value映射的哈希表。任何非空（non-null）的对象都可作为key或者value。 添加数据使用put(key,value)，取出数据使用get(key)，这两个基本操作的时间开销为常数。Hashtable通过initial capacity和load factor两个参数调整性能。通常缺省的loadfactor 0.75较好地实现了时间和空间的均衡。增大loadfactor可以节省空间但相应的查找时间将增大，这会影响像get和put这样的操作。使用Hashtable的简单示例如下，将1，2，3放到Hashtable中，他们的key分别是”one”，”two”，”three”： Hashtable numbers = new Hashtable(); numbers.put(“one”, new Integer(1)); numbers.put(“two”, new Integer(2)); numbers.put(“three”, new Integer(3)); 要取出一个数，比如2，用相应的key： Integer n = (Integer)numbers.get(“two”); System.out.println(“two = ” + n); 由于作为key的对象将通过计算其散列函数来确定与之对应的value的位置，因此任何作为key的对象都必须实现hashCode和equals方法。hashCode和equals方法继承自根类Object，如果你用自定义的类当作key的话，要相当小心，按照散列函数的定义，如果两个对象相同，即obj1.equals(obj2)=true，则它们的hashCode必须相同，但如果两个对象不同，则它们的hashCode不一定不同，如果两个不同对象的hashCode相同，这种现象称为冲突，冲突会导致操作哈希表的时间开销增大，所以尽量定义好的hashCode()方法，能加快哈希表的操作。 如果相同的对象有不同的hashCode，对哈希表的操作会出现意想不到的结果（期待的get方法返回null），要避免这种问题，只需要牢记一条：要同时复写equals方法和hashCode方法，而不要只写其中一个。 Hashtable是同步的。 HashMap类 HashMap和Hashtable类似，不同之处在于HashMap是非同步的，并且允许null，即nullvalue和nullkey。，但是将HashMap视为Collection时（values()方法可返回Collection），其迭代子操作时间开销和HashMap的容量成比例。因此，如果迭代操作的性能相当重要的话，不要将HashMap的初始化容量设得过高，或者loadfactor过低。 WeakHashMap类 WeakHashMap是一种改进的HashMap，它对key实行“弱引用”，如果一个key不再被外部所引用，那么该key可以被GC回收。 总结 如果涉及到堆栈，队列等操作，应该考虑用List，对于需要快速插入，删除元素，应该使用LinkedList，如果需要快速随机访问元素，应该使用ArrayList。 如果程序在单线程环境中，或者访问仅仅在一个线程中进行，考虑非同步的类，其效率较高，如果多个线程可能同时操作一个类，应该使用同步的类。 要特别注意对哈希表的操作，作为key的对象要正确复写equals和hashCode方法。 尽量返回接口而非实际的类型，如返回List而非ArrayList，这样如果以后需要将ArrayList换成LinkedList时，客户端代码不用改变。这就是针对抽象编程。 同步性Vector是同步的。这个类中的一些方法保证了Vector中的对象是线程安全的。而ArrayList则是异步的，因此ArrayList中的对象并不是线程安全的。因为同步的要求会影响执行的效率，所以如果你不需要线程安全的集合那么使用ArrayList是一个很好的选择，这样可以避免由于同步带来的不必要的性能开销。数据增长从内部实现机制来讲ArrayList和Vector都是使用数组(Array)来控制集合中的对象。当你向这两种类型中增加元素的时候，如果元素的数目超出了内部数组目前的长度它们都需要扩展内部数组的长度，Vector缺省情况下自动增长原来一倍的数组长度，ArrayList是原来的50%,所以最后你获得的这个集合所占的空间总是比你实际需要的要大。所以如果你要在集合中保存大量的数据那么使用Vector有一些优势，因为你可以通过设置集合的初始化大小来避免不必要的资源开销。使用模式在ArrayList和Vector中，从一个指定的位置（通过索引）查找数据或是在集合的末尾增加、移除一个元素所花费的时间是一样的，这个时间我们用t(1)表示。但是，如果在集合的其他位置增加或移除元素那么花费的时间会呈线形增长：t(n-i)，其中n代表集合中元素的个数，i代表元素增加或移除元素的索引位置。为什么会这样呢？因为在进行上述操作的时候集合中第i和第i个元素之后的所有元素都要执行位移的操作。这一切意味着什么呢？这意味着，你只是查找特定位置的元素或只在集合的末端增加、移除元素，那么使用Vector或ArrayList都可以。如果是其他操作，你最好选择其他的集合操作类。比如，LinkList集合类在增加或移除集合中任何位置的元素所花费的时间都是一样的?t(1)，但它在索引一个元素的使用缺比较慢－t(i),其中i是索引的位置.使用ArrayList也很容易，因为你可以简单的使用索引来代替创建iterator对象的操作。LinkList也会为每个插入的元素创建对象，所有你要明白它也会带来额外的开销。最后，建议使用一个简单的数组（Array）来代替Vector或ArrayList。尤其是对于执行效率要求高的程序更应如此。因为使用数组(Array)避免了同步、额外的方法调用和不必要的重新分配空间的操作。 https://www.cnblogs.com/kevinZhu/p/6953182.html]]></content>
      <categories>
        <category>01_software_engineering</category>
        <category>014_data_structure</category>
      </categories>
      <tags>
        <tag>Software Engineering</tag>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux内核剖析]]></title>
    <url>%2F2010%2F09%2F01%2F01_software_engineering%2F012_operating_system%2F0121_linux%2FLinux%E5%86%85%E6%A0%B8%E5%89%96%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Linux内核剖析历史和体系结构分析 由于本文的目标是对 Linux 内核进行介绍并探索其体系结构和主要组件，因此首先回顾一下 Linux 的简短历史，然后从较高的层次审视 Linux 内核的体系结构，最后介绍它的主要子系统。Linux 内核具有超过 600 万行的代码，因此本文不可能进行完整的介绍。请使用指向其他内容的链接进一步学习。 Linux 的简短历史尽管 Linux 绝对是最流行的开源操作系统，但是相对于其他操作系统的漫长历史来说，Linux 的历史非常短暂。在计算机出现早期，程序员是使用硬件语言在裸硬件上进行开发的。缺少操作系统就意味着在某个时间只有一个应用程序（和一个用户）可以使用这些庞大而又昂贵的设备。早期的操作系统是在 20 世纪 50 年代开发的，用来提供简单的开发体验。包括为 IBM 701 开发的 General Motors Operating System（GMOS）和 North American Aviation 为 IBM 709 开发的 FORTRAN Monitor System（FMS）。 在 20 世纪 60 年代，MIT（Massachusetts Institute of Technology）和一些公司为 GE-645 开发了一个名为 Multics（Multiplexed Information and Computing Service）的实验性的操作系统。这个操作系统的开发者之一 AT&amp;T 后来退出了 Multics，并在 1970 年开发了自己的名为 Unics 的操作系统。与这个操作系统一同诞生的是 C 语言，C 语言就是为此而开发的，然后它们使用 C 语言对操作系统进行了重写，使操作系统开发具有可移植性。 二十年后，Andrew Tanenbaum 创建了一个微内核版本的 UNIX®，名为 MINIX（代表 minimal UNIX），它可以在小型的个人计算机上运行。这个开源操作系统在 20 世纪 90 年代激发了 Linus Torvalds 开发 Linux 的灵感（请参看图 1 所示）。 图 1. 主要 Linux 内核发行版简史Linux 快速从一个个人项目进化成为一个全球数千人参与的开发项目。对于 Linux 来说，最为重要的决策之一是采用 GPL（GNU General Public License）。在 GPL 保护之下，Linux 内核可以防止商业使用，并且它还从 GNU 项目（Richard Stallman 开发，其源代码要比 Linux 内核大得多）的用户空间开发受益。这允许使用一些非常有用的应用程序，例如 GCC（GNU Compiler Collection）和各种 shell 支持。 Linux 内核简介现在让我们从一个比较高的高度来审视一下 GNU/Linux 操作系统的体系结构。您可以从两个层次上来考虑操作系统，如图 2 所示。 图 2. GNU/Linux 操作系统的基本体系结构最上面是用户（或应用程序）空间。这是用户应用程序执行的地方。用户空间之下是内核空间，Linux 内核正是位于这里。 GNU C Library （glibc）也在这里。它提供了连接内核的系统调用接口，还提供了在用户空间应用程序和内核之间进行转换的机制。这点非常重要，因为内核和用户空间的应用程序使用的是不同的保护地址空间。每个用户空间的进程都使用自己的虚拟地址空间，而内核则占用单独的地址空间。 更多信息，请参看 参考资料 一节中的链接。 Linux 内核可以进一步划分成 3 层。最上面是系统调用接口，它实现了一些基本的功能，例如 read 和 write。系统调用接口之下是内核代码，可以更精确地定义为独立于体系结构的内核代码。这些代码是 Linux 所支持的所有处理器体系结构所通用的。在这些代码之下是依赖于体系结构的代码，构成了通常称为 BSP（Board Support Package）的部分。这些代码用作给定体系结构的处理器和特定于平台的代码。 Linux 内核的属性在讨论大型而复杂的系统的体系结构时，可以从很多角度来审视系统。体系结构分析的一个目标是提供一种方法更好地理解源代码，这正是本文的目的。 Linux 内核实现了很多重要的体系结构属性。在或高或低的层次上，内核被划分为多个子系统。Linux 也可以看作是一个整体，因为它会将所有这些基本服务都集成到内核中。这与微内核的体系结构不同，后者会提供一些基本的服务，例如通信、I/O、内存和进程管理，更具体的服务都是插入到微内核层中的。每种内核都有自己的优点，不过这里并不对此进行讨论。 随着时间的流逝，Linux 内核在内存和 CPU 使用方面具有较高的效率，并且非常稳定。但是对于 Linux 来说，最为有趣的是在这种大小和复杂性的前提下，依然具有良好的可移植性。Linux 编译后可在大量处理器和具有不同体系结构约束和需求的平台上运行。一个例子是 Linux 可以在一个具有内存管理单元（MMU）的处理器上运行，也可以在那些不提供 MMU 的处理器上运行。Linux 内核的 uClinux 移植提供了对非 MMU 的支持。更详细信息请参看 参考资料 一节的内容。 Linux 内核的主要子系统现在使用图 3 中的分类说明 Linux 内核的主要组件。 图 3. Linux 内核的一个体系结构透视图系统调用接口SCI 层提供了某些机制执行从用户空间到内核的函数调用。正如前面讨论的一样，这个接口依赖于体系结构，甚至在相同的处理器家族内也是如此。SCI 实际上是一个非常有用的函数调用多路复用和多路分解服务。在 ./linux/kernel 中您可以找到 SCI 的实现，并在 ./linux/arch 中找到依赖于体系结构的部分。有关这个组件的更详细信息可以在 参考资料 一节中找到。 进程管理进程管理的重点是进程的执行。在内核中，这些进程称为_线程，代表了单独的处理器虚拟化（线程代码、数据、堆栈和 CPU 寄存器）。在用户空间，通常使用进程_ 这个术语，不过 Linux 实现并没有区分这两个概念（进程和线程）。内核通过 SCI 提供了一个应用程序编程接口（API）来创建一个新进程（fork、exec 或 Portable Operating System Interface [POSIX] 函数），停止进程（kill、exit），并在它们之间进行通信和同步（signal 或者 POSIX 机制）。 进程管理还包括处理活动进程之间共享 CPU 的需求。内核实现了一种新型的调度算法，不管有多少个线程在竞争 CPU，这种算法都可以在固定时间内进行操作。这种算法就称为 O(1) 调度程序，这个名字就表示它调度多个线程所使用的时间和调度一个线程所使用的时间是相同的。 O(1) 调度程序也可以支持多处理器（称为对称多处理器或 SMP）。您可以在 ./linux/kernel 中找到进程管理的源代码，在 ./linux/arch 中可以找到依赖于体系结构的源代码。在 参考资料 一节中可以了解有关这个算法的更多内容。 内存管理内核所管理的另外一个重要资源是内存。为了提高效率，如果由硬件管理虚拟内存，内存是按照所谓的内存页 方式进行管理的（对于大部分体系结构来说都是 4KB）。Linux 包括了管理可用内存的方式，以及物理和虚拟映射所使用的硬件机制。 不过内存管理要管理的可不止 4KB 缓冲区。Linux 提供了对 4KB 缓冲区的抽象，例如 slab 分配器。这种内存管理模式使用 4KB 缓冲区为基数，然后从中分配结构，并跟踪内存页使用情况，比如哪些内存页是满的，哪些页面没有完全使用，哪些页面为空。这样就允许该模式根据系统需要来动态调整内存使用。 为了支持多个用户使用内存，有时会出现可用内存被消耗光的情况。由于这个原因，页面可以移出内存并放入磁盘中。这个过程称为_交换_，因为页面会被从内存交换到硬盘上。内存管理的源代码可以在 ./linux/mm 中找到。 虚拟文件系统虚拟文件系统（VFS）是 Linux 内核中非常有用的一个方面，因为它为文件系统提供了一个通用的接口抽象。VFS 在 SCI 和内核所支持的文件系统之间提供了一个交换层（请参看图 4）。 图 4. VFS 在用户和文件系统之间提供了一个交换层在 VFS 上面，是对诸如 open、close、read 和 write 之类的函数的一个通用 API 抽象。在 VFS 下面是文件系统抽象，它定义了上层函数的实现方式。它们是给定文件系统（超过 50 个）的插件。文件系统的源代码可以在 ./linux/fs 中找到。 文件系统层之下是缓冲区缓存，它为文件系统层提供了一个通用函数集（与具体文件系统无关）。这个缓存层通过将数据保留一段时间（或者随即预先读取数据以便在需要是就可用）优化了对物理设备的访问。缓冲区缓存之下是设备驱动程序，它实现了特定物理设备的接口。 网络堆栈网络堆栈在设计上遵循模拟协议本身的分层体系结构。回想一下，Internet Protocol (IP) 是传输协议（通常称为传输控制协议或 TCP）下面的核心网络层协议。TCP 上面是 socket 层，它是通过 SCI 进行调用的。 socket 层是网络子系统的标准 API，它为各种网络协议提供了一个用户接口。从原始帧访问到 IP 协议数据单元（PDU），再到 TCP 和 User Datagram Protocol (UDP)，socket 层提供了一种标准化的方法来管理连接，并在各个终点之间移动数据。内核中网络源代码可以在 ./linux/net 中找到。 设备驱动程序Linux 内核中有大量代码都在设备驱动程序中，它们能够运转特定的硬件设备。Linux 源码树提供了一个驱动程序子目录，这个目录又进一步划分为各种支持设备，例如 Bluetooth、I2C、serial 等。设备驱动程序的代码可以在 ./linux/drivers 中找到。 依赖体系结构的代码尽管 Linux 很大程度上独立于所运行的体系结构，但是有些元素则必须考虑体系结构才能正常操作并实现更高效率。./linux/arch 子目录定义了内核源代码中依赖于体系结构的部分，其中包含了各种特定于体系结构的子目录（共同组成了 BSP）。对于一个典型的桌面系统来说，使用的是 i386 目录。每个体系结构子目录都包含了很多其他子目录，每个子目录都关注内核中的一个特定方面，例如引导、内核、内存管理等。这些依赖体系结构的代码可以在 ./linux/arch 中找到。 Linux 内核的一些有用特性如果 Linux 内核的可移植性和效率还不够好，Linux 还提供了其他一些特性，它们无法划分到上面的分类中。 作为一个生产操作系统和开源软件，Linux 是测试新协议及其增强的良好平台。Linux 支持大量网络协议，包括典型的 TCP/IP，以及高速网络的扩展（大于 1 Gigabit Ethernet [GbE] 和 10 GbE）。Linux 也可以支持诸如流控制传输协议（SCTP）之类的协议，它提供了很多比 TCP 更高级的特性（是传输层协议的接替者）。 Linux 还是一个动态内核，支持动态添加或删除软件组件。被称为动态可加载内核模块，它们可以在引导时根据需要（当前特定设备需要这个模块）或在任何时候由用户插入。 Linux 最新的一个增强是可以用作其他操作系统的操作系统（称为系统管理程序）。最近，对内核进行了修改，称为基于内核的虚拟机（KVM）。这个修改为用户空间启用了一个新的接口，它可以允许其他操作系统在启用了 KVM 的内核之上运行。除了运行 Linux 的其他实例之外， Microsoft® Windows® 也可以进行虚拟化。惟一的限制是底层处理器必须支持新的虚拟化指令。更多信息请参看 参考资料 一节的内容。 结束语本文对 Linux 内核体系结构及其特性和功能进行了简要介绍。有关内核的详细内容，可以参考每个 Linux 发行版中附带的 Documentation 目录。请一定查看本文末尾的 参考资料 一节，了解有关本文中所讨论主题的更详细信息。 https://www.ibm.com/developerworks/cn/linux/l-linux-kernel/]]></content>
      <categories>
        <category>01_software_engineering</category>
        <category>012_operating_system</category>
        <category>0121_linux</category>
      </categories>
      <tags>
        <tag>Software Engineering</tag>
        <tag>Operating System</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows端口占用关闭进程]]></title>
    <url>%2F2010%2F09%2F01%2F01_software_engineering%2F012_operating_system%2F0122_windows%2Fwindows%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E5%85%B3%E9%97%AD%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[windows端口占用关闭进程在windows命令行窗口下键入如下命令： netstat -aon 在Local Address下面可以看到被占用的端口号情况。比如80端口被PID为3096的进程占用了。 假如是希望查找指定的端口号被占用情况，可以使用如下命令： netstat -aon | findstr “80” 此命令就会查找到端口号中包含”80”的端口占用情况 知道了占用9000端口号的进程是PID为3096的进程，用下面的命令来查看具体的该进程的名称，使用如下命令： tasklist | findstr “3096” 假如这个进程占用了你的端口号，那么用这个方法干掉它。用Ctrl+Alt+Delete调出windows任务管理器窗口，可以直接通过名称找到这个占用的进程，然后选择结束进程。也可以通过PID号找到这个进程。点击&lt;查看&gt;-&gt;&lt;选择列&gt;，勾选&lt;PID(进程标识符号)&gt;，找到并结束进程。另外一个方法就是继续使用命令：C:>taskkill /f /t /javaw.exe]]></content>
      <categories>
        <category>01_software_engineering</category>
        <category>012_operating_system</category>
        <category>0122_windows</category>
      </categories>
      <tags>
        <tag>Software Engineering</tag>
        <tag>Operating System</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux内核剖析]]></title>
    <url>%2F2010%2F09%2F01%2F01_software_engineering%2F013_network%2F0131_http%2FHTTP2%E5%B9%95%E5%90%8E%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[HTTP/2 幕后原理HTTP/2 的请求/响应复用、报头压缩和服务器推送如何提升网站性能 HTTP/2 的首要目标是改善 Web 应用程序用户的体验。作为一个二进制协议，它拥有包括轻量型、安全和快速在内的所有优势。HTTP/2 保留了原始 HTTP 协议的语义，但更改了在系统之间传输数据的方式。这些复杂细节主要由客户端和服务器管理，所以网站和应用程序无需重大更改即可享受 HTTP/2 的优势。 本文将概述 HTTP/2，包括它试图解决的问题，以及它的大量新的性能增强特性 — 包括请求/响应复用、报头压缩和服务器推送。 HTTP 的历史在深入介绍 HTTP/2 协议的细节之前，让我们回到过去并回顾一下HTTP 中的起源。 该协议于 1989 年首次曝光，以 HTTP 0.9 的形式面世。Timothy Berners-Lee 在瑞士日内瓦附近的 CERN 上首次提到它时，它仅包含 1 行代码。唯一的方法是 GET，还有一个像下面这个示例这样简单的请求：GET /index.html。响应同样很简单，仅包含所请求的文件。 HTTP 0.9 不是一个正式标准，通过这种方式引用它是为了将它与随后的正式版本区分开。1996 年，推出了 HTTP 1.0 作为 IEFT 标准（依据 RFC 1945）。1999 年，在 RFC 2616 中发布了 HTTP 1.1。第一个主要版本中的缺点促使人们在 1999 年进行了一次小幅修订，引入了大量可选特性和零碎细节 — 并消除了一些不好的方面。 几乎没有浏览器（或服务器）实现会采用该协议的每个方面，这导致不同浏览器间的用户体验不一致。显然，浏览器供应商无法实现 HTTP 1.1 中引入的 HTTP 管道的性能增强特性。 您可以亲自查看：在最近的一次演示中，Cloudflare 通过 HTTP 1.1 和 HTTP/2 加载了 200 个图像切片，然后比较了加载时间。 随着网络的使用变得更加普遍，性能需求呈指数级增长，而对 HTTP 的需求阻碍了性能提升。开发人员开始创建工具来克服该协议的不足。例如，HTTP 对 TCP 套接字的低效使用限制了性能，所以开发人员退而使用精心设计的服务器架构(racks of servers)来满足应用程序需求。从这个角度讲，未能让管道正常工作，促使人们开始着重反思 HTTP 的需求。 15 年后，才成立了 HTTPbis 工作组来正式识别该协议的棘手问题，并最终起草对 HTTP/2 的预期。怀着显著改善最终用户对 HTTP 1.1 延迟的认知的使命，该工作组的协议推荐包含针对 “线头阻塞” 问题、报头压缩和服务器推送的精选解决方案。RFC 7540 (HTTP/2) 和 7541 (HPACK) 的结合，预示着 Web 应用程序性能将急剧提升。 HTTP 的现状自万维网诞生以来，网页变得愈加复杂。第一批网页非常简单，仅包含文本：没有图像，没有 CSS，没有 JavaScript，只有普通的 HTML。快进到今天，平均每个网页就包含 100 多个下载资源，大小约为 2,500 KB。总传输大小自 2012 年 5 月以来增长了 250%，这种持续增长没有出现缓和迹象。 图 1. 总传输大小和总请求数 (2012-2017)，来源：HTTPArchive 工具和变通方案尽管互联网确实能快速提供高度复杂的内容，但出现这样的结果并不是因为 HTTP 1.1 协议（_尽管_采用了该协议）。在当前版本中，HTTP 无法满足如今的 Web 体验需求。因此，Web 开发人员针对这些性能问题提供了一系列变通方案。让我们来看一些比较流行的工具和它们修补的问题。 线头阻塞HTTP 1.0 仅允许通过一个 TCP 连接发出一个请求。这引发了所谓的 “线头阻塞” 问题，迫使浏览器等待缓慢的响应。HTTP 1.1 通过_管道_解决了这个问题，管道使浏览器能并行发出多个请求。但是，浏览器供应商很难实现管道，而且大多数浏览器（包括 Firefox）在发布时都会默认禁用该特性。Chrome 甚至完全删除了它。 多个 TCP 连接打开 TCP 连接需要很高的成本，而且我们对客户端应如何使用它们知之甚少。唯一的协议规定是，每个主机最多可以打开 2个连接。由于只有 2 个 TCP 连接，开发人员为了能够展示一个现代页面需要竞争这两个名额 — 所以他们找到了一种方法来绕过这一限制。 通过使用一种称为域分片（domain sharding）的流行技术，开发人员能创建多个主机，每个主机提供一个网站所需资源的一部分。切分已变得非常普遍，网页加载期间打开的平均 TCP 连接数量也因此达到约 35 个（来源：HTTPArchive）。 浏览器供应商不甘示弱，他们也违反了该协议，任意增加浏览器实现中允许的开放连接数量。这有助于并行化各个浏览器中的资源加载，但没有充分利用 TCP 套接字。下表显示了每个主机名允许打开的端口的最高数量，以及最流行的 3 个浏览器在这方面的不同。 表 1. 并行打开的 TCP 连接的最大数量（来源：browserscope.org) 浏览器 每个主机名的最大并行连接数 Chrome 24 Firefox 6 Internet Explorer 12 11 浏览器实现中的不一致意味着，用户冲浪体验的质量取决于他们选择的浏览器，而不是网站的设计和构思有多精巧。 资源内联和级联为了追求更高性能，Web 应用程序开发人员采用的聪明技巧并不只有域切分。 文件串联创建一个包含全部所需资源的大文件。为网站的所有 CSS 创建一个文件，为 JavaScript 创建一个文件，为包含网站图标的图像子画面表创建另一个文件。 资源内联将 CSS 和 JavaScript 直接嵌入在 HTML 中，这使得嵌入图像也成为可能。对图像进行 base64 编码，然后在加载网页时进行解码。 这些技术都不可取，尤其是从设计角度讲。在这两种情况下，页面的结构都与样式组合在一起，图像解码也会消耗很多时间。缓存也无法轻松实现。 但是，如果目标只是减少请求的文件数量，那么这些变通方案是成功的。随着文件请求减少，需要打开的 TCP 套接字也会减少。 最吸引人的特性HTTP/2 的大多数实用特性归功于 Google 在 SPDY 协议上开展的工作。在 HTTPbis 工作组开始起草 HTTP/2 RFC 的第一个版本时，SPDY 已证明一个主要 HTTP 版本更新切实可行。因为已经部署并开始采用 SPDY，所以有证据表明更新的协议在自然环境下具有更高的性能。 HTTP/2 成功的关键在于，它实现了显著的性能改善，同时保持了 HTTP 范例，以及 HTTP 和 HTTPS 模式。该工作组规定，向 HTTP/2 的迁移必须透明，而且使用者不会受到任何影响。 该协议最吸引人的特性包括： 新升级路径 二进制分帧 请求/响应复用 报头压缩 流优先化 服务器推送 流控制 让我们来查看每个特性。 新升级路径HTTP/2 升级路径与标准路径稍有不同，省去了一些协商。对于基于 HTTP/2 的安全连接，无法通过升级标头请求切换协议，并收到一条让人安心的“101 switching”HTTP 状态。相反，通过使用一个名为应用层协议协商 (ALPN) 的新扩展，客户端向服务器告知它能理解的通信协议（按偏好排序）。服务器然后使用该列表中它也理解的第一个协议作为响应。 SPDY 需要一个安全连接，虽然社区迫于压力会建立这样的连接，但 HTTP/2 规范没有强制要求这么做。但是，所有主要浏览器供应商都仅在 TLS 上实现 HTTP/2，而且不支持不安全的连接。这实际上会迫使 Web 应用程序实现者对所有 HTTP/2 流量使用 TLS（来源：caniuse.com）。curl 用户仍可采用通过 HTTP 升级标头的升级路径，因为它将实现既明确又安全的连接。 二进制协议或许 HTTP/2 的最重要改变是转换为二进制协议。对于开发人员，这可以说是性能增强的焦点。新协议称为二进制分帧层（binary framing layer），它重新设计了编码机制，而没有修改方法、动词和标头的熟悉语义。 最重要的是，所有通信都在单个 TCP 连接上执行，而且该连接在整个对话期间一直处于打开状态。这可能得益于二进制协议将通信分解为帧的方式：这些帧交织在客户端与服务器之间的双向逻辑流中。 连接的拓扑结构正如我提到的，在 HTTP/2 的新范例中，仅在客户端与服务器之间建立了一个 TCP 连接，而且该连接在交互持续期间一直处于打开状态。在此连接上，消息是通过逻辑流进行传递的。一条_消息_包含一个完整的帧序列。在经过整理后，这些帧表示一个响应或请求。 图 2 演示了连接组件之间的关系，展示了一个用于建立多个流的连接。在流 1 中，发送了一条请求消息，并返回了相应的响应消息。 图 2. HTTP/2 连接的拓扑结构 我们将分别查看每个概念。 连接和流仅与一个对等节点建立一个连接，并在该连接上传输多个流。因为流可以交织，所以可以同时快速的传输多个流。 消息_消息_是一组帧。在对等节点上重建这些帧时，它们形成一个完整的请求或响应。特定消息的帧在同一个流上发送，这意味着一个请求或响应只能映射到一个可识别的流。 帧_帧_是通信的基本单位。每个帧有一个标头，其中包含帧的长度和类型、一些布尔标志、一个保留位和一个流标识符，如图 3 所示。 图 3. 帧分解 长度length 字段记录帧的大小，它最多可在一个 DATA 帧中携带 224 个字节（约 16 MB），但默认的最大值设置为 214 个字节 (16 KB)。帧大小可以通过协商调得更高一点。 类型type 字段标识帧的用途，可以是以下 10 种类型之一： HEADERS：帧仅包含 HTTP 标头信息。 DATA：帧包含消息的所有或部分有效负载。 PRIORITY：指定分配给流的重要性。 RST_STREAM：错误通知：一个推送承诺遭到拒绝。终止流。 SETTINGS：指定连接配置。 PUSH_PROMISE：通知一个将资源推送到客户端的意图。 PING：检测信号和往返时间。 GOAWAY：停止为当前连接生成流的停止通知。 WINDOW_UPDATE：用于管理流的流控制。 CONTINUATION：用于延续某个标头碎片序列。 参见规范的 11.2 节了解每种帧类型的功能的更多细节。 标志flag 字段是一个布尔值，指定帧的状态信息： DATA 帧可定义两个布尔标志：END_STREAM 和 PADDED，前者表示数据流结束，后者表示存在填充数据。 HEADERS 帧可以将相同的标志指定为 DATA 帧，并添加两个额外的标志：END_HEADERS 和 PRIORITY，前者表示标头帧结束，后者表示设置了流优先级。 PUSH_PROMISE 帧可以设置 END_HEADERS 和 PADDED 标志。 所有其他帧类型都无法设置标志。 流标识符流标识符用于跟踪逻辑流的帧成员关系。成员每次仅属于一条消息和流。流可以提供优先级建议，这有助于确定分配给它的网络资源。我稍后会更详细地解释流优先化。 请求/响应复用单一 TCP 连接的问题在于，一次只能发出一个请求，所以客户端必须等到收到响应后才能发出另一个请求。这就是 “线头阻塞” 问题。正如之前讨论的，典型的变通方案是打开多个连接；每个请求一个连接。但是，如果可以将消息分解为更小的独立部分并通过连接发送，此问题就会迎刃而解。 这正是 HTTP/2 希望达到的目标。将消息分解为帧，为每帧分配一个流标识符，然后在一个 TCP 连接上独立发送它们。此技术实现了完全双向的请求和响应消息复用，如下图所示。 图 4. 在 TCP 连接上交织的帧 图 4 中的图解显示在一个连接上快速传输了 3 个流。服务器发送两个响应，客户端发送一个请求。 在流 1 中，服务器为一个响应发送 HEADERS 帧；在流 2 中，它为另一个响应发送 HEADERS 帧，随后为两个响应发送 DATA 帧。两个响应按如图所示的方式交织。在服务器发送响应的过程中，客户端发送一条新消息的 HEADERS 和 DATA 帧作为请求。这些帧也与响应帧交织在一起，如下图所示。 图 5. HTTP/2 将请求/响应帧交织在一起 所有帧在另一端重新组装，以形成完整的请求或响应消息。 帧交织有许多好处： 所有请求和响应都在一个套接字上发生。 所有响应或请求都无法相互阻塞。 减少了延迟。 提高了页面加载速度。 消除了对 HTTP 1.1 工具的需求。 图 6. 将 HTTP 请求映射到 HTTP/2 帧 我们将左侧的一个 HTTP 请求映射到右侧的一个 HEADERS 帧。 在 HEADERS 帧中，设置了两个标志。第一个是 END_STREAM，它设置为 true（由加号表示），表明该帧是给定请求的最后一帧。END_HEADERS 标志也设置为 true，表明该帧是流中最后一个包含标头信息的帧。 HEADERS 帧中的标头属性反映了 HTTP 1.1 请求中设置的属性。因为 HTTP/2 一定要保持 HTTP 协议的语义，所以必须这么做。 接下来，让我们来看看该请求的响应。 将 HTTP 请求映射到帧图 7 的左侧是一个 HTTP 1.1 标头响应。右侧是使用两个 HTTP/2 帧表示的同一个响应：HEADERS 和 DATA。 图 7. 将 HTTP 响应映射到 HTTP/2 帧 在 HEADERS 帧中，END_STREAM 表明该帧不是流中的最后一帧，而 END_HEADER 表明它是最后一个包含标头信息的帧。在 DATA帧中，END_STREAM 表明它是最后一帧。 报头压缩HTTP/2 协议拥有配套的 HPACK。HPACK 的目的是减少客户端请求与服务器响应之间的标头信息重复所导致的开销。报头压缩的实现方式是，要求客户端和服务器都维护之前看见的标头字段的列表。未来在构建引用了已看见标头列表的消息时可以使用此列表。 图 8. 压缩同一个连接上的两个请求的标头 在图 8 中的两个请求中，标头信息是重复的。唯一的不同在请求的资源上（已采用黄色突出显示）。HPACK 报头压缩可以在这里派上用场。在第一个请求后，它仅需发送与前一个标头的不同之处，因为服务器保留着以前看见的标头的列表。除非设置了标头值，否则会假设后续请求拥有与之前的请求相同的标头值。 流优先化消息帧通过流进行发送。每个流都分配了一个优先级，用于确定它的处理顺序，以及它将收到的资源量。 将该优先级输入到给定流的标头帧或优先级帧中，优先级可以是 0 到 256 之间的任何数字。 可以定义依赖关系，允许在一个资源之前加载另一个资源。也可以将优先级组合到一个依赖树中，让开发人员对分配给每个流的重要性有更多控制权。 图 9. 用于流优先化的依赖树 在图 9 中，字母表示流标识符，数字表示分配给每个流的权重。树的根是流 A，首先会向它分配资源，然后才向依赖它的流 B 和 C 分配资源。为流 B 分配了 40% 的可用资源，流 C 收到了 60% 的可用资源。流 C 是流 D 和 E 的父流，二者分别从其父流收到相同的资源配额。 流优先级仅是对服务器的建议，可以动态更改或完全忽略。在起草 HTTP/2 协议的过程中，工作组认为允许客户端强迫服务器遵守特定资源分配是不对的。相反，服务器可以自由调整优先级，使其与自己的能力匹配。 服务器推送服务器推送使服务器能预测客户端请求的资源需求。然后，在完成请求处理之前，它可以将这些资源发送到客户端。 要了解服务器推送的好处，可以考虑一个包含图像和其他依赖项（比如 CSS 和 JavaScript 文件）的网页。客户端发出一个针对该网页的请求。服务器然后分析所请求的页面，确定呈现它所需的资源，并主动将这些资源发送到客户端的缓存。在执行所有这些操作的同时，服务器仍在处理原始网页请求。客户端收到原始网页请求的响应时，它需要的资源已经位于缓存中。 那么 HTTP/2 如何管理服务器推送而不会让客户端过载？针对希望发送的每个资源，服务器会发送一个 PUSH_PROMISE 帧，但客户端可通过发送 RST_STREAM 帧作为响应来拒绝推送（例如，如果浏览器的缓存中已包含该资源）。重要的是所有PUSH_PROMISE 都在响应数据之前发送，所以客户端知道它需要请求哪些资源。 流控制流控制管理数据的传输，使发送者不会让接收者不堪重负。它允许接收者停止或减少发送的数据量。例如，参阅一个提供点播视频的流媒体服务。观看者观看一个视频流时，服务器正在向客户端发送数据。如果视频暂停，客户端会通知服务器停止发送视频数据，以避免耗尽它的缓存。 打开一个连接后，服务器和客户端会立即交换 SETTINGS 帧来确定流控制窗口的大小。默认情况下，该大小设置为约 65 KB，但可通过发出一个 WINDOW_UPDATE 帧为流控制设置不同的大小。 HTTP/2 的普及情况供应商几乎都采用了 HTTP/2。在浏览器领域，所有主要浏览器目前都只支持基于 TLS 的新协议。在编写本文时，全球的支持率已超过 80%。 服务器支持率也有所增加，所有主要服务器系列的当前版本都支持 HTTP/2。您的托管服务提供商很可能已支持 HTTP/2。可以在 HTTP/2 规范的 Wiki 页面上跟踪它的所有已知服务器实现。 工具支持也很丰富，所有您最喜欢的实用工具都支持 HTTP/2。Wireshark 对希望调试服务器与客户端之间的 HTTP/2 通信的开发人员最重要。 HTTP/2 与您的关系Web 用户不关心您使用何种协议来提供内容，只要它速度够快就行。您可能已通过优化网站加载资源的方式，努力为客户提供他们想要的资源。借助 HTTP/2，您不再需要串联文件，将图标整理到一个图像中，设置大量域，或者内联资源。 简言之，HTTP/2 避免了对变通方案的需求。事实上，继续使用我在本文中介绍的性能工具，可能阻碍您的网站从 HTTP/2 性能增强中受益。 所以对大多数开发人员而言，最重要的问题是：现在是否适合针对 HTTP/2 重构我的网站？在我看来，这很大程度上取决于与应用程序组成和所使用的浏览器相关的因素。以下是一个平衡法则：您不希望不公平对待使用旧浏览器的用户，但希望提供更快的整体用户体验。 针对 HTTP/2 的优化是一个未知领域，尤其是在最佳实践方面。它不仅仅是消除变通方案并期待获得最佳成果的一种途径。我们每个人都必须亲自研究。在此过程中，我们会发现提升性能的新方法、HTTP/2 在自然环境下的运行效果，哪个服务器拥有最高性能的实现，等等。 对 Web 开发而言，HTTP/2 代表着一个美好的新世界。大胆的开发人员在接受它带来的挑战的同时也将获得收益。 相关主题 HTTP/2 解释 迁移到 HTTP/2：考虑因素和权衡 高性能浏览器连网（第 12 章） Java EE Servlet 4.0 特性 https://www.ibm.com/developerworks/cn/web/wa-http2-under-the-hood/index.html]]></content>
      <categories>
        <category>01_software_engineering</category>
        <category>013_network</category>
        <category>0131_http</category>
      </categories>
      <tags>
        <tag>Software Engineering</tag>
        <tag>Operating System</tag>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP应用程序的通信连接模式]]></title>
    <url>%2F2010%2F09%2F01%2F01_software_engineering%2F013_network%2F0132_tcp_ip%2FTCPIP%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%80%9A%E4%BF%A1%E8%BF%9E%E6%8E%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[TCP/IP 应用程序的通信连接模式TCP/IP 应用层与应用程序 TCP/IP 起源于二十世纪 60 年代末美国政府资助的一个分组交换网络研究项目，它是一个真正的开放协议，很多不同厂家生产各种型号的计算机，它们运行完全不同的操作系统，但 TCP/IP 协议组件允许它们互相进行通信。现在 TCP/IP 已经从一个只供一些科学家使用的小实验网成长为一个由成千上万的计算机和用户构成的全球化网络，TCP/IP 也已成为全球因特网（Internet）的基础，越来越多的 TCP/IP 互联网应用和企业商业应用正在改变着世界。 TCP/IP 通讯协议采用了四层的层级模型结构（注：这与 OSI 七层模型不相同），每一层都调用它的下一层所提供的网络任务来完成自己的需求。TCP/IP 的每一层都是由一系列协议来定义的。这 4 层分别为： 应用层 (Application)：应用层是个很广泛的概念，有一些基本相同的系统级 TCP/IP 应用以及应用协议，也有许多的企业商业应用和互联网应用。 传输层 (Transport)：传输层包括 UDP 和 TCP，UDP 几乎不对报文进行检查，而 TCP 提供传输保证。 网络层 (Network)：网络层协议由一系列协议组成，包括 ICMP、IGMP、RIP、OSPF、IP(v4,v6) 等。 链路层 (Link)：又称为物理数据网络接口层，负责报文传输。 图１显示了 TCP/IP 层级模型结构，应用层之间的协议通过逐级调用传输层（Transport layer）、网络层（Network Layer）和物理数据链路层（Physical Data Link）而可以实现应用层的应用程序通信互联。 应用层需要关心应用程序的逻辑细节，而不是数据在网络中的传输活动。应用层其下三层则处理真正的通信细节。在 Internet 整个发展过程中的所有思想和着重点都以一种称为 RFC（Request For Comments）的文档格式存在。针对每一种特定的 TCP/IP 应用，有相应的 RFC 文档。一些典型的 TCP/IP 应用有 FTP、Telnet、SMTP、SNTP、REXEC、TFTP、LPD、SNMP、NFS、INETD 等。RFC 使一些基本相同的 TCP/IP 应用程序实现了标准化，从而使得不同厂家开发的应用程序可以互相通信。 图 １ TCP/IP 层级模型结构 然而除了这些已经实现标准化的系统级 TCP/IP 应用程序外，在企业商业应用和互联网应用开发中，存在着大量的商业应用程序通信互联问题。如图 １ 显示，其中的应用层所包含应用程序主要可以分成两类，即系统级应用和商业应用，互联网商业应用是商业应用中的主要形式之一。 不同开发商和用户在开发各自商业应用通信程序时也存在有许多不同的设计方式。关于 TCP/IP 应用层以下的技术文献与书籍早已是汗牛充栋，但是关于 TCP/IP 应用本身，尤其是关于商业应用的通信设计模式技术讨论方面的文章还是比较少的。TCP/IP 应用通信设计模式实际上是在 TCP/IP 基础编程之上的一种应用编程设计方式，也属于一种应用层协议范畴，其可以包含有 TCP/IP 地址族模式设计、I/O 模式设计、通信连接模式设计以及通信数据格式设计等。鉴于目前讨论 TCP/IP 商业应用程序设计模式问题这方面的文章还很少见，本文尝试给出一些通信连接模式设计中共同的概念与一些典型的设计模式，在以后的文章中将继续讨论地址族模式设计、I/O 模式设计、以及通信数据格式设计等方面的模式设计实现话题。 通信连接模式设计主要考虑内容有： 通信两端程序建立通信方式 通信连接方式 通信报文发送与接收方式 以下内容将介绍建立通信的 Client/Server 模型，然后逐一介绍通信连接模式设计所需要考虑的这些内容。 传输层接口 APIs 与 TCP/IP 应用程序 C/S 模型传输层接口 APIsTCP/IP 应用层位于传输层之上，TCP/IP 应用程序需要调用传输层的接口才能实现应用程序之间通信。目前使用最广泛的传输层的应用编程接口是套接字接口（Socket）。Socket APIs 是于 1983 年在 Berkeley Socket Distribution (BSD) Unix 中引进的。 1986 年 AT&amp;T 公司引进了另一种不同的网络层编程接口 TLI（Transport Layer Interface），1988 年 AT&amp;T 发布了一种修改版的 TLI，叫做 XTI（X/open Transport interface）。XTI/TLI 和 Socket 是用来处理相同任务的不同方法。关于 TCP/IP APIs 使用文章与书籍已相当多，本文则是侧重于如何组合使用这些 APIs 来进行 TCP/IP 应用程序连接模式设计，并归纳出几种基本应用连接模式。 如图 ２ 显示，应用层是通过调用传输层接口 APIs（Socket 或 XTI/TLI）来与传输层和网络层进行通信的。 图 ２ 传输层接口 不管是使用何种编程接口，要在两个机器或两个程序之间建立通信，通信双方必须建立互相一致的通信模式。如果双方的通信设计模式不一致就无法建立有效的通信连接。 以下是经常使用的 socket APIs，是建立 TCP/IP 应用程序的标准接口，也是影响 TCP/IP 应用程序通信方式的几个主要 APIs，不同 APIs 组合再结合系统调用可以实现不同方式的应用。Sockets 支持多种传输层和网络层协议，支持面向连接和无连接的数据传输，允许应用分布式工作。 socket()：是用来创建一个 socket，socket 表示通信中的一个节点，其可以在一个网络中被命名，用 socket 描述符表示，socket 描述符类似于 Unix 中的文件描述符。 bind()：是用来把本地 IP 层地址和 TCP 层端口赋予 socket。 listen() ：把未连接的 socket 转化成一个等待可连接的 socket，允许该 socket 可以被请求连接，并指定该 socket 允许的最大连接数。 accept()：是等待一个连接的进入，连接成功后，产生一个新的 socket 描述符，这个新的描述符用来建立与客户端的连接。 connect()：用来建立一个与服务端的连接。 send()：发送一个数据缓冲区，类似 Unix 的文件函数 write()。另外 sendto() 是用在无连接的 UDP 程序中，用来发送自带寻址信息的数据包。 recv()：接收一个数据缓冲区，类似 Unix 的文件函数 readI()。另外 recvfrom() 是用在无连接的 UDP 程序中，用来接收自带寻址信息的数据包。 close()：关闭一个连接 Client/Server 模型Sockets 是以 Client 和 Server 交互通信方式来使用的。典型的系统配置是把 Server 放在一台机器中，而把 Client 放在另一台机器中，Client 连接到 Server 交换信息。一个 socket 有一系列典型的事件流。例如，在面向连接的 Client/Server 模型中，Server 端的 socket 总是等待一个 Client 端的请求。要实现这个请求，Server 端首先需要建立能够被 Client 使用的地址，当地址建立后，Server 等待 Client 请求服务。当一个 Client 通过 socket 连接到 Server 后，Client 与 Server 之间就可以进行信息交换。Client/Server 是通信程序设计的基本模式。从软件开发的角度讲，TCP/IP 应用程序都是基于 Client/Server 方式的。注意本篇文章以下 Client/Server 概念是针对程序内部调用 Socket API 所讲的概念，与针对整个程序甚至针对机器而讲的客户端 / 服务器概念有所不同。用 Server APIs 建立的程序可以被当作客户端使用，用 Client APIs 建立的程序也可以被用作服务器端使用。建立 Server 需要的 APIs 有 socket(), bind(), listen(), accept()，建立 Client 需要的 APIs 有 Socket(), Connect()。在实际应用开发中，同一个程序里往往同时可以有 Client 和 Server 的代码，或者多种形式的组合。在实际应用编程中，针对 Socket APIs 不同有效组合，结合系统调用可以有多种复杂的设计变化。 面向连接的应用编程存在三类基本的不同级别的设计方式范畴，根据 Socket APIs 从上到下顺序依次是： Client/Server 通信建立方式 Client/Server 通信连接方式 Client/Server 通信发送与接收方式 下面内容以面向连接的 Socket 应用编程为例来说明这几种不同通信范畴的设计实现。 Client/Server 建立方式设计概述一个 Client 连接一个 Server如果只有两台机器之间连接，那么一个是 Client，另一个是 Server，如下面图 3 所示。这是最简单的 TCP/IP 的应用，也是 TCP/IP 应用早期的 Peer to Peer (P2P) 概念。其流程基本如图 ４ 所示。 图 ３ TCP/IP 应用单点 Client/Server 图 4 显示了 TCP/IP 应用编程最基本的 Client/Server 模式，显示了基本的 Client/Server 通信所需要调用的 Socket APIs 以及顺序。 图 ４ TCP/IP 应用编程基本 Client/Server 模式 多个 Client 连接一个 Server多个 Client 同时连接一个 Server 是 TCP/IP 应用的主流形式，如图 ５ 所示，其中 Client 连接数可以从几个到成千上万。 图 ５ TCP/IP 应用多 Client 端的 Client/Server 由于 socket APIs 缺省方式下都是阻塞方式的，实现多个 Client 同时连接一个 Server 就需要特别的设计。其实现方式可以有多种不同的设计，这其中也涉及 I/O 模式设计。下面将展开介绍其中几种设计形式。 利用一个 Client 连接一个 Server 形式实现多 Client 连接 从程序设计角度讲，只要 Client 和 Server 端口是一对一形式，那么就属于一个 Client 连接一个 Server 形式。在处理多个 Client 端连接时，Server 端轮流使用多个端口建立多个 Client-Server 连接，连接关闭后，被释放端口可以被循环使用。在这种多连接形式中需要谨慎处理 Client 端如何获取使用 Server 端的可用端口。比如图 ６ 显示 Server 有一个服务于所有进程的进程可以先把 Server 端的可用端口发送给 Client 端，Client 端再使用该端口建立连接来处理业务。Server 针对每一个 Client 连接用一个专门的进程来处理。由于可用端口数有限，Server 用一个有限循环来处理每一个可用的端口连接。由于新端口需要用 bind() 来绑定，所以需要从 bind() 开始到 close() 结束都需要包含在循环体内。 图 ６ 利用一对一 Client-Server 模式实现多 Client 连接 使用多个 accept() 实现多 Client 连接 多进程 Server 一般有一个专注进程是服务于每一个连接的。当 Client 端完成连接后，专注进程可以循环被另外的连接使用。使用多个 accept() 也可以实现处理多 Client 连接。多 accept() 的 Server 也只有一个 socket()，一个 bind()，一个 listen()，这与通常情况一样。但是它建立许多工作子进程，每一个工作子进程都有 accept()，这样可以为每一个 Client 建立 socket 描述符。如图 ７ 所示，由于 accept() 连接成功后，会产生一个新的 socket 描述符，这样通过循环多进程利用 accept() 产生的多 socket 描述符就可以与多个 Client 进行连接通信。循环体是从 accept() 开始到 close() 结束的。 图 ７ 使用多 accept() 实现多 Client 连接 使用并发 Server 模式实现多 Client 连接 并发服务器模式曾经是 TCP/IP 的主流应用程序设计模式，得到广泛使用，目前互联网上仍有相当多的应用使用此种模式。其设计思路是在 accept 之后 fork 出一个子进程。因为 socket 会产生监听 socket 描述符 listenfd，accept 会产生连接 socket 描述符 connfd。连接建立后，子进程继承连接描述符服务于 Client，父进程则继续使用监听描述符等待另外一个 Client 的连接请求，以产生另外一个连接 socket 描述符和子进程。如图 ８ 所示，accept() 接收到一个 Client 连接后，产生一个新的 socket 描述符，通过 fork() 系统调用，用一个子进程来处理该 socket 描述符的连接服务。而父进程可以立即返回到 accept()，等待一个新的 Client 请求，这就是典型的并发服务器模式。并发服务器模式同时处理的最大并发 Client 连接数由 listen() 的第二个参数来指定。 图 ８ TCP/IP 应用并发 Server 使用 I/O 多路技术实现多 Client 连接 以上三种连接设计，多 Server 端口、多 accept() 和并发服务器模式，都是通过 fork() 系统调用产生多进程来实现多 Client 连接的。使用 I/O 多路技术也可以同时处理多个输入与输出问题，即用一个进程同时处理多个文件描述符。I/O 多路技术是通过 select() 或 poll() 系统调用实现的。poll() 与 select() 功能完全相同，但是 poll() 可以更少使用内存资源以及有更少的错误发生。select() 调用需要与操作文件描述符集的 APIs 配合使用。select() 系统调用可以使一个进程检测多个等待的 I/O 是否准备好，当没有设备准备好时，select() 处于阻塞状态中，其中任一设备准备好后，select() 函数返回调用。select() API 本身也有一个超时时间参数，超时时间到后，无论是否有设备准备好，都返回调用。其流程如图 9 所示。在 socket APIs listen() 和 accept() 之间插入 select() 调用。使用这三个宏 FD_ZERO()、FD_CLR() 和 FD_SET()，在调用 select() 前设置 socket 描述符屏蔽位，在调用 select() 后使用 FD_ISSET 来检测 socket 描述符集中对应于 socket 描述符的位是否被设置。 FD_ISSET() 就相当通知了一个 socket 描述符是否可以被使用，如果该 socket 描述符可用，则可对该 socket 描述符进行读写通信操作。通常，操作系统通过宏 FD_SETSIZE 来声明在一个进程中 select() 所能操作的文件或 socket 描述符的最大数目。更详细的 I/O 多路技术实现，可以参考其他相关文献。 图 ９ I/O 多路技术实现多连接的 Server 一个 Client 连接多个 Server一个 Client 连接多个 Server 这种方式很少见，主要用于一个客户需要向多个服务器发送请求情况，比如一个 Client 端扫描连接多个 Server 端情况。如图 １０ 所示。此种方式设计主要是 Client 端应用程序的逻辑设计，通常需要在 Client 端设计逻辑循环来连接多个 Server，在此不做更多描述。 图10 单 Client 对多 Server 复杂 Client/Server 设计与现代 P2P最近几年，对等网络技术 ( Peer-to-Peer，简称 P2P) 迅速成为计算机界关注的热门话题之一，以及影响 Internet 未来的科技之一。与早期点对点 (Peer to Peer) 的 Client/Server 模式不同，现在的 P2P 模式是指每个结点既可充当服务器，为其他结点提供服务，同时也可作为客户端享用其他结点提供的服务。实际上 P2P 模式仍然是基于 Client/Server 模式的，每个通信节点都既是 Server，又是 Client，P2P 是基于复杂 Client/Server 设计的 TCP/IP 应用。图 １１ 显示 P2P 模式下两个用户 PC 之间的对等连接。 图 １１ P2P 模式 在技术上，P2P 本身是基于 TCP/IP Client/Server 技术的一种设计模式思想， P2P 也属于网络应用层技术，与 Web 和 FTP 等应用是并列的。只是 P2P 应用在设计实现上更要复杂的多。P2P 技术实现的协同工作是无需专门的服务器支持的 (Serverless)，这里的服务器概念与 Client/Server 中的 Server 概念是不一样的。在传统意义上中心服务器机器上往往运行的是 TCP/IP 应用的 Server 端程序，所以传统意义上的 Server 概念在机器与应用上是重合的。如果更改 TCP/IP 的应用设计，使应用程序既可做 Server 又可做 Client，就可以实现无中心服务器的 P2P 模式。 在设计模式上，P2P 模式实现了网络终端用户不依赖中心服务器或者服务商而直接进行信息和数据交换的可能，因此 P2P 正在改变着整个互联网的一些基础应用，从而极大地增加了用户之间的信息沟通和交流能力。目前互联网的 P2P 应用与网络都正在飞速发展，一些典型的 P2P 应用程序比如有 BitTorrent, eDonkey 等，另外一些即时通信（IM）类软件比如 MSN、QQ 等也正在向无中心服务器模式转变。无中心服务器的 Internet 应用程序大大降低应用提供商的运营成本，而且减少人们对于 Server 稳定性的依赖。 Client/Server 通信连接方式设计Client/Server 通信方式建立后，下一步就需要考虑通信连接的方式，主要有两种方式的连接，即长连接通信与短连接通信。通信连接方式涉及到的 APIs 主要是 connect() 和 accept()。要实现某种 Client/Server 方式，就必须考虑用某种特定的连接方式。 短连接通信短连接通信是指 Client 方与 Server 方每进行一次通信报文收发交易时才进行通讯连接，交易完毕后立即断开连接。此种方式常用于多个 Client 连接一个 Server 情况，常用于机构与用户之间通信，比如 OLTP（联机事务处理）类应用。在短连接情况下，Client 端完成任务后，就关闭连接并退出。在 Server 端，可以通过循环 accept()，使 Server 不会退出，并连续处理 Client 的请求。图 １２ 显示了一般情况下短连接通信模式的 Socket 事件流，不同设计的连接多 Client 的 Server 有不同的循环流程。 图 １２ 短连接模式通信 长连接通信长连接通信是指 Client 方与 Server 方先建立通讯连接，连接建立后不会断开，然后再进行报文发送和接收，报文发送与接收完毕后，原来连接不会断开而继续存在，因此可以连续进行交易报文的发送与接收。这种方式下由于通讯连接一直存在，其 TCP/IP 状态是 Established，可以用操作系统的命令 netstat 查看连接是否建立。由于在长连接情况下，Client 端和 Server 端一样可以固定使用一个端口，所以长连接下的 Client 也需要使用 bind() 来绑定 Client 的端口。在长连接方式下，需要循环读写通信数据。为了区分每一次交易的通信数据，每一次交易数据常常需要在数据头部指定该次交易的长度，接收 API 需要首先读出该长度，然后再按该长度读出指定长度的字节。长连接方式常用于一个 Client 端对一个 Server 端的通讯，一般常用于机构与机构之间的商业应用通信，以处理机构之间连续的大量的信息数据交换。或者说可用于两个系统之间持续的信息交流情况。通常为了加快两个系统之间的信息交流，通常还需要建立几条长连接的并行通信线路。图 １３ 显示了一般情况下长连接通信模式的 socket 事件流，可见其最大特点是 Client 和 Server 都有循环体，而且循环体只包含读写 APIs。 图 １３ 长连接模式通信 Client/Server 通信发送与接收方式设计在通信数据发送与接收之间也存在不同的方式，即同步和异步两种方式。这里的同步和异步与 I/O 层次的同异步概念不同。主要涉及 socket APIs recv() 和 send() 的不同组合方式。 同步发送与接收从应用程序设计的角度讲，报文发送和接收是同步进行的，既报文发送后，发送方等待接收方返回消息报文。同步方式一般需要考虑超时问题，即报文发出去后发送方不能无限等待，需要设定超时时间，超过该时间后发送方不再处于等待状态中，而直接被通知超时返回。同步发送与接收经常与短连接通信方式结合使用，称为同步短连接通信方式，其 socket 事件流程可如上面的图 １２ 所示。 异步发送与接收从应用程序设计的角度讲，发送方只管发送数据，不需要等待接收任何返回数据，而接收方只管接收数据，这就是应用层的异步发送与接收方式。要实现异步方式，通常情况下报文发送和接收是用两个不同的进程来分别处理的，即发送与接收是分开的，相互独立的，互不影响。异步发送与接收经常与长连接通信方式结合使用，称为异步长连接通信方式。从应用逻辑角度讲，这种方式又可分双工和单工两种情况。 异步双工 异步双工是指应用通信的接收和发送在同一个程序中，而有两个不同的子进程分别负责发送和接收，异步双工模式是比较复杂的一种通信方式，有时候经常会出现在不同机构之间的两套系统之间的通信。比如银行与银行之间的信息交流。它也可以适用在现代 P2P 程序中。如图 １４ 所示，Server 和 Client 端分别 fork 出两个子进程，形成两对子进程之间的连接，两个连接都是单向的，一个连接是用于发送，另一个连接用于接收，这样方式的连接就被称为异步双工方式连接。 图 １４ 长连接异步双工模式 异步单工 应用通信的接收和发送是用两个不同的程序来完成，这种异步是利用两对不同程序依靠应用逻辑来实现的。图 １５ 显示了长连接方式下的异步单工模式，在通信的 A 和 B 端，分别有两套 Server 和 Client 程序，B 端的 Client 连接 A 端的 Server，A 端的 Server 只负责接收 B 端 Client 发送的报文。A 端的 Client 连接 B 端的 Server，A 端 Client 只负责向 B 端 Server 发送报文。 图 １５ 长连接异步单工模式 典型通信连接模式综上所述，在实际 TCP/IP 应用程序设计中，就连接模式而言，我们需要考虑 Client/Server 建立方式、Client/Server 连接方式、Client/Server 发送与接收方式这三个不同级别的设计方式。实际 TCP/IP 应用程序连接模式可以是以上三类不同级别 Client/Server 方式的组合。比如一般 TCP/IP 相关书籍上提供的 TCP/IP 范例程序大都是同步短连接的 Client/Server 程序。有的组合是基本没有实用价值的，比较常用的有价值的组合是以下几种： 同步短连接 Server/Client 同步长连接 Server/Client 异步短连接 Server/Client 异步长连接双工 Server/Client 异步长连接单工 Server/Client 其中异步长连接双工是较为复杂的一种通信方式，有时候经常会出现在不同银行或不同城市之间的两套系统之间的通信，比如国家金卡工程。由于这几种通信方式比较固定，所以可以预先编制这几种通信方式的模板程序。 总结本文探讨了 TCP/IP 应用程序中连接模式的设计。在以后的文章中还将继续讨论 TCP/IP 应用程序设计中的其他方面的设计话题，包括地址族模式设计、I/O 模式设计、以及通信数据格式设计等。 https://www.ibm.com/developerworks/cn/aix/library/0807_liugb_tcpip/]]></content>
      <categories>
        <category>01_software_engineering</category>
        <category>013_network</category>
        <category>0132_tcp_ip</category>
      </categories>
      <tags>
        <tag>Software Engineering</tag>
        <tag>Operating System</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重要经历]]></title>
    <url>%2F2009%2F09%2F01%2F09_important_experience%2Findex%2F</url>
    <content type="text"><![CDATA[重要经历生命里的每一个点都会最终连成线。如果不好好捋一捋，永远是一团乱麻。 home 家庭 school 学校 middle_little 中小学 degree 学位 bachelor 学士 acm 算法竞赛 shangxuetang 培训 bachelor_project 毕业设计 master 硕士 scholar 学术 e_business 电商 start_up 创业 master_project 毕业设计 doctor 博士 study 学习 cert_exam 考证 chinese_classics 国学 health 养生 language 语言 study_plan 学习计划 super_memory 超强记忆 work 工作 erp 企业应用 smart_home 智能家居 iot 物联网 sport 运动 badminton 羽毛球 basketball 篮球 football 足球 run 跑步 walk 徒步 food 美食 media 影音 guitar 吉他 music 音乐 movie 电影 joy 娱乐 toy 玩具 four_drive 四驱车 magic_cube 魔方 game 游戏 pc_game 电脑游戏 cs 反恐精英 fifa 实况足球 nba 2K篮球 portable_game 掌机游戏 nitendo 任天堂 sony PlayPortableStation系列 travel 旅游]]></content>
      <categories>
        <category>09_important_experience</category>
      </categories>
      <tags>
        <tag>Important Experience</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目管理]]></title>
    <url>%2F2009%2F09%2F01%2F08_project_manage%2Findex%2F</url>
    <content type="text"><![CDATA[项目管理技术是一个团队的力量 scrum 敏捷开发 scrum_tool 敏捷工具 microsoft_project zentao devops 开发运维 continuous_integration 持续集成 nexus hudson jenkins sonarqube ops hardware software]]></content>
      <categories>
        <category>08_project_manage</category>
      </categories>
      <tags>
        <tag>Project Manage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[架构设计]]></title>
    <url>%2F2009%2F09%2F01%2F07_frame_design%2Findex%2F</url>
    <content type="text"><![CDATA[架构设计高屋建瓴，水到渠成 app_scene 应用场景 app_solution 解决方案 industry_case 行业案例 erp 企业应用 smart_home 智能家居 iot 物联网]]></content>
      <categories>
        <category>07_frame_design</category>
      </categories>
      <tags>
        <tag>Frame Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[技术框架]]></title>
    <url>%2F2009%2F09%2F01%2F06_tech_frame%2Findex%2F</url>
    <content type="text"><![CDATA[技术框架无数前辈工程实践的结晶 j2ee java企业开发 component 框架组件 component_base 组件基础 data_decode 数据编解码 xml json gson protocol_buffer protocol 通信协议 mqtt network 网络 netty NIO框架 cdn docker 容器 rpc netty_rpc dubbo dubbox thrift finagle grpc motan navi-pbrpc pigeon poppy venus mq activemq hivemq kafka security 安全 aes md5 rsa shiro cas 单点登录 project_frame 项目框架 spring spring_boot spring_mvc spring_jdbc spring_data spring_security spring_cloud spring_data_flow struts orm hibernate mybatis project_case 工程案例 ddd 领域驱动设计 jdon axon enode bigdata db 数据库技术 mycat hive impala etl flume storm dispacher corntab oozie zookeeper distribute_compute hadoop spark platform elk elasticsearch filebeat logstash kibana engine commend_engine search_engine lucene solr xunsearch openstack fusion_insight spider 爬虫 webmagic]]></content>
      <categories>
        <category>06_tech_frame</category>
      </categories>
      <tags>
        <tag>Tech Frame</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据存储]]></title>
    <url>%2F2009%2F09%2F01%2F05_data_storage%2Findex%2F</url>
    <content type="text"><![CDATA[数据存储数据从哪里来，到哪里去 rdbs 关系向数据库 mysql oracle cache 缓存 redis memcache guava_cache session_share 会话共享 dfs 分布式文件系统 fastdfs hdfs nosql mongodb tsdb 时序数据库 postgresql opentsdb influxdb hbase]]></content>
      <categories>
        <category>05_data_storage</category>
      </categories>
      <tags>
        <tag>Data Storage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码开发]]></title>
    <url>%2F2009%2F09%2F01%2F04_code_r%26d%2Findex%2F</url>
    <content type="text"><![CDATA[代码开发前辈编码套路经验总结 ooa 面向对象分析 ood 面向对象设计 design_pattern 设计模式 soa 面向服务架构 ddd 领域驱动设计 cqrs code_review 代码审查 review_tool 审查工具 ali_guidelines checkstyle findbugs pmd]]></content>
      <categories>
        <category>04_code_r&amp;d</category>
      </categories>
      <tags>
        <tag>Code R&amp;D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[应用开发]]></title>
    <url>%2F2009%2F09%2F01%2F03_application_r%26d%2Findex%2F</url>
    <content type="text"><![CDATA[应用开发工欲善其事，必先利其器 ide 集成开发环境 eclipse myeclipse android_studio xcode idea webstorm server 服务程序 nginx tengine jetty tomcat build_tool 构建工具 maven gradle version_control 版本控制 svn 集中式 git 分布式 github gitee coding]]></content>
      <categories>
        <category>03_application_r&amp;d</category>
      </categories>
      <tags>
        <tag>Application R&amp;D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程语言]]></title>
    <url>%2F2009%2F09%2F01%2F02_code_language%2Findex%2F</url>
    <content type="text"><![CDATA[编程语言入门计算机以来，熟悉的开发语言 c/c++ ACM就靠这和Dev_cpp了 java 主线 java_base 语言基础 dynamic_proxy jvm 环境基础 class_loader 类加载器 memory_model 内存模型 gc 垃圾回收 set_utils 集合工具 array_list linked_list hashmap treemap concurrent_hashmap apache_commons io 输入输出流 nio net 网络 socket tcp_ip thread 多线程 thread_pool 线程池 concurrent_package 并发包 optimize 性能优化 asynchronous 异步 optimize_lock 锁优化 script 脚本辅助 javascript 应用显示层的基础技术 linux_shell 后端开发的必备技能 awk python 热门且应用广泛 web 网页相关 html 页面显示 web_cache 缓存 cookie 客户端小量缓存 session 服务端小量缓存 template_engine 模板引擎 velocity thymeleaf freemarker android 智能硬件APP ui 界面交互 component 四大组件 net 网络通信 jni 本地通信库 ble 蓝牙 object_c 黑苹果Hackintosh的Xcode nodejs 微信公众号，营销、控制智能硬件 wechat_program 还是微信，感受了小程序的第一缕春风 angularjs 前后端分离 scala 大数据高并发(Java Ship) golang 与scala对比研习(C/C++ Ship) php 各种cms（WordPress、DedeCMS、PhpCMS）里diy]]></content>
      <categories>
        <category>02_code_language</category>
      </categories>
      <tags>
        <tag>Code Language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程]]></title>
    <url>%2F2009%2F09%2F01%2F01_software_engineering%2Findex%2F</url>
    <content type="text"><![CDATA[软件工程纪念计算机408的几门课程 计算机组成原理 操作系统 计算机网络 数据结构 感谢曾经的ACM之旅 算法设计与分析 各大高校OJ（PKU、BJTU、ZSU、HDU、HNU…吧啦吧啦…）]]></content>
      <categories>
        <category>01_software_engineering</category>
      </categories>
      <tags>
        <tag>Software Engineering</tag>
      </tags>
  </entry>
</search>
