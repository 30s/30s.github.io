<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>博乐园</title>
  
  <subtitle>Coding bots ...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://30s.github.io/"/>
  <updated>2018-03-06T10:41:27.907Z</updated>
  <id>https://30s.github.io/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Jdon Framework</title>
    <link href="https://30s.github.io/2017/01/01/06_tech_frame/064_project_case/0641_ddd/jdon/jdon_framework/"/>
    <id>https://30s.github.io/2017/01/01/06_tech_frame/064_project_case/0641_ddd/jdon/jdon_framework/</id>
    <published>2017-01-01T14:51:11.000Z</published>
    <updated>2018-03-06T10:41:27.907Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开源项目：Jdon-Framework"><a href="#开源项目：Jdon-Framework" class="headerlink" title="开源项目：Jdon Framework"></a>开源项目：<a href="http://www.jdon.com/jdonframework/" target="_blank" rel="noopener">Jdon Framework</a></h1><p><a href="http://www.jdon.com/jdonframework/download.html" target="_blank" rel="noopener">下载</a>      <a href="http://www.jdon.com/jdonframework/manual.htm" target="_blank" rel="noopener">文档</a>       <a href="http://www.jdon.com/jdonframework/app.htm" target="_blank" rel="noopener">演示</a>      <a href="http://en.jdon.com/" target="_blank" rel="noopener">jdon英文</a>       <a href="https://github.com/banq/jdonframework" target="_blank" rel="noopener">Github项目</a></p><blockquote><p>项目新闻：<br>2017-06 增加了类似erLang/akka的Actor并发模型的账户转账测试代码和多核并发测试代码，验证Jdon框架支持无锁并发和内存事务<br>2015-05-06  Jdon框架研发思考<br>2014-01-16 Jdonframework PPT进入SlideShare 2013前Top 1%<br>2013-09-29 6.6.8 CQRS Command/Event异步并发输入输出。</p></blockquote><p>　　Jdon Framework是一个实施DDD+CQRS+EventSourcing架构的Java reactive开源框架，能够快速地将领域驱动设计(DDD)落地为异步、高并发、高吞吐量的Java应用系统 。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;开源项目：Jdon-Framework&quot;&gt;&lt;a href=&quot;#开源项目：Jdon-Framework&quot; class=&quot;headerlink&quot; title=&quot;开源项目：Jdon Framework&quot;&gt;&lt;/a&gt;开源项目：&lt;a href=&quot;http://www.jdon
      
    
    </summary>
    
      <category term="06_tech_frame" scheme="https://30s.github.io/categories/06-tech-frame/"/>
    
    
      <category term="DDD" scheme="https://30s.github.io/tags/DDD/"/>
    
      <category term="CQRS" scheme="https://30s.github.io/tags/CQRS/"/>
    
      <category term="EventSourcing" scheme="https://30s.github.io/tags/EventSourcing/"/>
    
      <category term="Java Reactive" scheme="https://30s.github.io/tags/Java-Reactive/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理</title>
    <link href="https://30s.github.io/2010/09/01/01_software_engineering/011_computer_principle/index/"/>
    <id>https://30s.github.io/2010/09/01/01_software_engineering/011_computer_principle/index/</id>
    <published>2010-09-01T12:00:00.000Z</published>
    <updated>2018-03-07T13:37:12.382Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第1篇-概论"><a href="#第1篇-概论" class="headerlink" title="第1篇 概论"></a>第1篇 概论</h1><h2 id="第1章-计算机系统概论"><a href="#第1章-计算机系统概论" class="headerlink" title="第1章 计算机系统概论"></a>第1章 计算机系统概论</h2><h3 id="1-1-计算机系统简介"><a href="#1-1-计算机系统简介" class="headerlink" title="1.1 计算机系统简介"></a>1.1 计算机系统简介</h3><h3 id="1-2-计算机的基本组成"><a href="#1-2-计算机的基本组成" class="headerlink" title="1.2 计算机的基本组成"></a>1.2 计算机的基本组成</h3><p>　　控制器，运算器，存储器，输入设备，输出设备。</p><h3 id="1-3-计算机硬件的主要技术指标"><a href="#1-3-计算机硬件的主要技术指标" class="headerlink" title="1.3 计算机硬件的主要技术指标"></a>1.3 计算机硬件的主要技术指标</h3><p>　　CPU的字长、时钟主频、运算速度、容量与可靠性。</p><h2 id="第2章-计算机的发展及应用"><a href="#第2章-计算机的发展及应用" class="headerlink" title="第2章 计算机的发展及应用"></a>第2章 计算机的发展及应用</h2><h3 id="2-1-计算机的发展史"><a href="#2-1-计算机的发展史" class="headerlink" title="2.1 计算机的发展史"></a>2.1 计算机的发展史</h3><h3 id="2-2-计算机的应用"><a href="#2-2-计算机的应用" class="headerlink" title="2.2 计算机的应用"></a>2.2 计算机的应用</h3><h3 id="2-3-计算机的展望"><a href="#2-3-计算机的展望" class="headerlink" title="2.3 计算机的展望"></a>2.3 计算机的展望</h3><hr><h1 id="第2篇-计算机系统的硬件结构"><a href="#第2篇-计算机系统的硬件结构" class="headerlink" title="第2篇 计算机系统的硬件结构"></a>第2篇 计算机系统的硬件结构</h1><p><img src="https://botlab.oss-cn-shenzhen.aliyuncs.com/blog/img/01_software_engineering/computer_hardware_composite.jpg" alt="计算机系统硬件组成"></p><h2 id="第3章-系统总线"><a href="#第3章-系统总线" class="headerlink" title="第3章 系统总线"></a>第3章 系统总线</h2><h3 id="3-1-总线的基本概念"><a href="#3-1-总线的基本概念" class="headerlink" title="3.1 总线的基本概念"></a>3.1 总线的基本概念</h3><h3 id="3-2-总线的分类"><a href="#3-2-总线的分类" class="headerlink" title="3.2 总线的分类"></a>3.2 总线的分类</h3><h3 id="3-3-总线特性及性能指标"><a href="#3-3-总线特性及性能指标" class="headerlink" title="3.3 总线特性及性能指标"></a>3.3 总线特性及性能指标</h3><h3 id="3-4-总线结构"><a href="#3-4-总线结构" class="headerlink" title="3.4 总线结构"></a>3.4 总线结构</h3><h3 id="3-5-总线控制"><a href="#3-5-总线控制" class="headerlink" title="3.5 总线控制"></a>3.5 总线控制</h3><h2 id="第4章-存储器"><a href="#第4章-存储器" class="headerlink" title="第4章 存储器"></a>第4章 存储器</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><h3 id="4-2-主存储器"><a href="#4-2-主存储器" class="headerlink" title="4.2 主存储器"></a>4.2 主存储器</h3><h3 id="4-3-高速缓冲存储器"><a href="#4-3-高速缓冲存储器" class="headerlink" title="4.3 高速缓冲存储器"></a>4.3 高速缓冲存储器</h3><h3 id="4-4-辅助存储器"><a href="#4-4-辅助存储器" class="headerlink" title="4.4 辅助存储器"></a>4.4 辅助存储器</h3><h2 id="第5章-输入输出系统"><a href="#第5章-输入输出系统" class="headerlink" title="第5章 输入输出系统"></a>第5章 输入输出系统</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><h3 id="5-2-I-O设备"><a href="#5-2-I-O设备" class="headerlink" title="5.2 I/O设备"></a>5.2 I/O设备</h3><h3 id="5-3-I-O接口"><a href="#5-3-I-O接口" class="headerlink" title="5.3 I/O接口"></a>5.3 I/O接口</h3><h3 id="5-4-程序查询方式"><a href="#5-4-程序查询方式" class="headerlink" title="5.4 程序查询方式"></a>5.4 程序查询方式</h3><h3 id="5-5-程序中断方式"><a href="#5-5-程序中断方式" class="headerlink" title="5.5 程序中断方式"></a>5.5 程序中断方式</h3><h3 id="5-6-DMA方式"><a href="#5-6-DMA方式" class="headerlink" title="5.6 DMA方式"></a>5.6 DMA方式</h3><h3 id="附录5A-ASCⅡ码"><a href="#附录5A-ASCⅡ码" class="headerlink" title="附录5A ASCⅡ码"></a>附录5A ASCⅡ码</h3><h3 id="附录5B-BCD码"><a href="#附录5B-BCD码" class="headerlink" title="附录5B BCD码"></a>附录5B BCD码</h3><h3 id="附录5C-奇偶校检码"><a href="#附录5C-奇偶校检码" class="headerlink" title="附录5C 奇偶校检码"></a>附录5C 奇偶校检码</h3><hr><h1 id="第3篇-中央处理器"><a href="#第3篇-中央处理器" class="headerlink" title="第3篇 中央处理器"></a>第3篇 中央处理器</h1><h2 id="第6章-计算机的运算方法"><a href="#第6章-计算机的运算方法" class="headerlink" title="第6章 计算机的运算方法"></a>第6章 计算机的运算方法</h2><h3 id="6-1-无符号数和有符号数"><a href="#6-1-无符号数和有符号数" class="headerlink" title="6.1 无符号数和有符号数"></a>6.1 无符号数和有符号数</h3><h3 id="6-2-数的定点表示和浮点表示"><a href="#6-2-数的定点表示和浮点表示" class="headerlink" title="6.2 数的定点表示和浮点表示"></a>6.2 数的定点表示和浮点表示</h3><h3 id="6-3-定点运算"><a href="#6-3-定点运算" class="headerlink" title="6.3 定点运算"></a>6.3 定点运算</h3><h3 id="6-4-浮点四则运算"><a href="#6-4-浮点四则运算" class="headerlink" title="6.4 浮点四则运算"></a>6.4 浮点四则运算</h3><h3 id="6-5-算术逻辑单元"><a href="#6-5-算术逻辑单元" class="headerlink" title="6.5 算术逻辑单元"></a>6.5 算术逻辑单元</h3><h3 id="附录6A-各种进位制"><a href="#附录6A-各种进位制" class="headerlink" title="附录6A 各种进位制"></a>附录6A 各种进位制</h3><h3 id="附录6B-阵列乘法器和阵列除法器"><a href="#附录6B-阵列乘法器和阵列除法器" class="headerlink" title="附录6B 阵列乘法器和阵列除法器"></a>附录6B 阵列乘法器和阵列除法器</h3><h3 id="附录6C-7418l逻辑电路"><a href="#附录6C-7418l逻辑电路" class="headerlink" title="附录6C 7418l逻辑电路"></a>附录6C 7418l逻辑电路</h3><h2 id="第7章-指令系统"><a href="#第7章-指令系统" class="headerlink" title="第7章 指令系统"></a>第7章 指令系统</h2><h3 id="7-1-机器指令"><a href="#7-1-机器指令" class="headerlink" title="7.1 机器指令"></a>7.1 机器指令</h3><h3 id="7-2-操作数类型和操作类型"><a href="#7-2-操作数类型和操作类型" class="headerlink" title="7.2 操作数类型和操作类型"></a>7.2 操作数类型和操作类型</h3><h3 id="7-3-寻址方式"><a href="#7-3-寻址方式" class="headerlink" title="7.3 寻址方式"></a>7.3 寻址方式</h3><h3 id="7-4-指令格式举例"><a href="#7-4-指令格式举例" class="headerlink" title="7.4 指令格式举例"></a>7.4 指令格式举例</h3><h3 id="7-5-RISC技术"><a href="#7-5-RISC技术" class="headerlink" title="7.5 RISC技术"></a>7.5 RISC技术</h3><h2 id="第8章-CPU的结构和功能"><a href="#第8章-CPU的结构和功能" class="headerlink" title="第8章 CPU的结构和功能"></a>第8章 CPU的结构和功能</h2><h3 id="8-1-CPU的结构"><a href="#8-1-CPU的结构" class="headerlink" title="8.1 CPU的结构"></a>8.1 CPU的结构</h3><h3 id="8-2-指令周期"><a href="#8-2-指令周期" class="headerlink" title="8.2 指令周期"></a>8.2 指令周期</h3><h3 id="8-3-指令流水"><a href="#8-3-指令流水" class="headerlink" title="8.3 指令流水"></a>8.3 指令流水</h3><h3 id="8-4-中断系统"><a href="#8-4-中断系统" class="headerlink" title="8.4 中断系统"></a>8.4 中断系统</h3><hr><h1 id="第4篇-控制单元"><a href="#第4篇-控制单元" class="headerlink" title="第4篇 控制单元"></a>第4篇 控制单元</h1><h2 id="第9章-控制单元的功能"><a href="#第9章-控制单元的功能" class="headerlink" title="第9章 控制单元的功能"></a>第9章 控制单元的功能</h2><h3 id="9-1-微操作命令的分析"><a href="#9-1-微操作命令的分析" class="headerlink" title="9.1 微操作命令的分析"></a>9.1 微操作命令的分析</h3><h3 id="9-2-控制单元的功能"><a href="#9-2-控制单元的功能" class="headerlink" title="9.2 控制单元的功能"></a>9.2 控制单元的功能</h3><h2 id="第10章-控制单元的设计"><a href="#第10章-控制单元的设计" class="headerlink" title="第10章 控制单元的设计"></a>第10章 控制单元的设计</h2><h3 id="10-1-组合逻辑设计"><a href="#10-1-组合逻辑设计" class="headerlink" title="10.1 组合逻辑设计"></a>10.1 组合逻辑设计</h3><h3 id="10-2-微程序设计"><a href="#10-2-微程序设计" class="headerlink" title="10.2 微程序设计"></a>10.2 微程序设计</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第1篇-概论&quot;&gt;&lt;a href=&quot;#第1篇-概论&quot; class=&quot;headerlink&quot; title=&quot;第1篇 概论&quot;&gt;&lt;/a&gt;第1篇 概论&lt;/h1&gt;&lt;h2 id=&quot;第1章-计算机系统概论&quot;&gt;&lt;a href=&quot;#第1章-计算机系统概论&quot; class=&quot;header
      
    
    </summary>
    
      <category term="01_software_engineering" scheme="https://30s.github.io/categories/01-software-engineering/"/>
    
      <category term="011_computer_principle" scheme="https://30s.github.io/categories/01-software-engineering/011-computer-principle/"/>
    
    
      <category term="Software Engineering" scheme="https://30s.github.io/tags/Software-Engineering/"/>
    
      <category term="Computer Principle" scheme="https://30s.github.io/tags/Computer-Principle/"/>
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="https://30s.github.io/2010/09/01/01_software_engineering/012_operating_system/index/"/>
    <id>https://30s.github.io/2010/09/01/01_software_engineering/012_operating_system/index/</id>
    <published>2010-09-01T12:00:00.000Z</published>
    <updated>2018-03-06T10:37:56.385Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-操作系统引论"><a href="#第一章-操作系统引论" class="headerlink" title="第一章 操作系统引论"></a>第一章 操作系统引论</h1><h2 id="1-1-操作系统的目标和作用"><a href="#1-1-操作系统的目标和作用" class="headerlink" title="1.1 操作系统的目标和作用"></a>1.1 操作系统的目标和作用</h2><h2 id="1-2-操作系统的发展过程"><a href="#1-2-操作系统的发展过程" class="headerlink" title="1.2 操作系统的发展过程"></a>1.2 操作系统的发展过程</h2><h2 id="1-3-操作系统的基本特性"><a href="#1-3-操作系统的基本特性" class="headerlink" title="1.3 操作系统的基本特性"></a>1.3 操作系统的基本特性</h2><h2 id="1-4-操作系统的主要功能"><a href="#1-4-操作系统的主要功能" class="headerlink" title="1.4 操作系统的主要功能"></a>1.4 操作系统的主要功能</h2><h2 id="1-5-OS结构设计"><a href="#1-5-OS结构设计" class="headerlink" title="1.5 OS结构设计"></a>1.5 OS结构设计</h2><h1 id="第二章-进程管理"><a href="#第二章-进程管理" class="headerlink" title="第二章 进程管理"></a>第二章 进程管理</h1><h2 id="2-1-进程的基本概念"><a href="#2-1-进程的基本概念" class="headerlink" title="2.1 进程的基本概念"></a>2.1 进程的基本概念</h2><h2 id="2-2-进程控制"><a href="#2-2-进程控制" class="headerlink" title="2.2 进程控制"></a>2.2 进程控制</h2><h2 id="2-3-进程同步"><a href="#2-3-进程同步" class="headerlink" title="2.3 进程同步"></a>2.3 进程同步</h2><h2 id="2-4-经典进程的同步问题"><a href="#2-4-经典进程的同步问题" class="headerlink" title="2.4 经典进程的同步问题"></a>2.4 经典进程的同步问题</h2><h2 id="2-5-进程通信"><a href="#2-5-进程通信" class="headerlink" title="2.5 进程通信"></a>2.5 进程通信</h2><h2 id="2-6-线程"><a href="#2-6-线程" class="headerlink" title="2.6 线程"></a>2.6 线程</h2><h1 id="第三章-处理机调度与死锁"><a href="#第三章-处理机调度与死锁" class="headerlink" title="第三章 处理机调度与死锁"></a>第三章 处理机调度与死锁</h1><h2 id="3-1-处理机调度的层次"><a href="#3-1-处理机调度的层次" class="headerlink" title="3.1 处理机调度的层次"></a>3.1 处理机调度的层次</h2><h2 id="3-2-调度队列模型和调度准则"><a href="#3-2-调度队列模型和调度准则" class="headerlink" title="3.2 调度队列模型和调度准则"></a>3.2 调度队列模型和调度准则</h2><h2 id="3-3-调度算法"><a href="#3-3-调度算法" class="headerlink" title="3.3 调度算法"></a>3.3 调度算法</h2><h2 id="3-4-实时调度"><a href="#3-4-实时调度" class="headerlink" title="3.4 实时调度"></a>3.4 实时调度</h2><h2 id="3-5-产生死锁的原因和必要条件"><a href="#3-5-产生死锁的原因和必要条件" class="headerlink" title="3.5 产生死锁的原因和必要条件"></a>3.5 产生死锁的原因和必要条件</h2><h2 id="3-6-预防死锁的方法"><a href="#3-6-预防死锁的方法" class="headerlink" title="3.6 预防死锁的方法"></a>3.6 预防死锁的方法</h2><h2 id="3-7-死锁的检测与解除"><a href="#3-7-死锁的检测与解除" class="headerlink" title="3.7 死锁的检测与解除"></a>3.7 死锁的检测与解除</h2><h1 id="第四章-存储器管理"><a href="#第四章-存储器管理" class="headerlink" title="第四章 存储器管理"></a>第四章 存储器管理</h1><h2 id="4-1-存储器的层次结构"><a href="#4-1-存储器的层次结构" class="headerlink" title="4.1 存储器的层次结构"></a>4.1 存储器的层次结构</h2><h2 id="4-2-程序的装入和链接"><a href="#4-2-程序的装入和链接" class="headerlink" title="4.2 程序的装入和链接"></a>4.2 程序的装入和链接</h2><h2 id="4-3-连续分配方式"><a href="#4-3-连续分配方式" class="headerlink" title="4.3 连续分配方式"></a>4.3 连续分配方式</h2><h2 id="4-4-基本分页存储管理方式"><a href="#4-4-基本分页存储管理方式" class="headerlink" title="4.4 基本分页存储管理方式"></a>4.4 基本分页存储管理方式</h2><h2 id="4-5-基本分段存储管理方式"><a href="#4-5-基本分段存储管理方式" class="headerlink" title="4.5 基本分段存储管理方式"></a>4.5 基本分段存储管理方式</h2><h2 id="4-6-虚拟存储器的基本概念"><a href="#4-6-虚拟存储器的基本概念" class="headerlink" title="4.6 虚拟存储器的基本概念"></a>4.6 虚拟存储器的基本概念</h2><h2 id="4-7-请求分页存储管理方式"><a href="#4-7-请求分页存储管理方式" class="headerlink" title="4.7 请求分页存储管理方式"></a>4.7 请求分页存储管理方式</h2><h2 id="4-8-页面置换算法"><a href="#4-8-页面置换算法" class="headerlink" title="4.8 页面置换算法"></a>4.8 页面置换算法</h2><h2 id="4-9-请求分段存储管理方式"><a href="#4-9-请求分段存储管理方式" class="headerlink" title="4.9 请求分段存储管理方式"></a>4.9 请求分段存储管理方式</h2><h1 id="第五章-设备管理"><a href="#第五章-设备管理" class="headerlink" title="第五章 设备管理"></a>第五章 设备管理</h1><h2 id="5-1-I-O系统"><a href="#5-1-I-O系统" class="headerlink" title="5.1 I/O系统"></a>5.1 I/O系统</h2><h2 id="5-2-I-0控制方式"><a href="#5-2-I-0控制方式" class="headerlink" title="5.2 I/0控制方式"></a>5.2 I/0控制方式</h2><h2 id="5-3-缓冲管理"><a href="#5-3-缓冲管理" class="headerlink" title="5.3 缓冲管理"></a>5.3 缓冲管理</h2><h2 id="5-4-I-O软件"><a href="#5-4-I-O软件" class="headerlink" title="5.4 I/O软件"></a>5.4 I/O软件</h2><h2 id="5-5-设备分配"><a href="#5-5-设备分配" class="headerlink" title="5.5 设备分配"></a>5.5 设备分配</h2><h2 id="5-6-磁盘存储器的管理"><a href="#5-6-磁盘存储器的管理" class="headerlink" title="5.6 磁盘存储器的管理"></a>5.6 磁盘存储器的管理</h2><h1 id="第六章-文件管理"><a href="#第六章-文件管理" class="headerlink" title="第六章 文件管理"></a>第六章 文件管理</h1><h2 id="6-1-文件和文件系统"><a href="#6-1-文件和文件系统" class="headerlink" title="6.1 文件和文件系统"></a>6.1 文件和文件系统</h2><h2 id="6-2-文件的逻辑结构"><a href="#6-2-文件的逻辑结构" class="headerlink" title="6.2 文件的逻辑结构"></a>6.2 文件的逻辑结构</h2><h2 id="6-3-外存分配方式"><a href="#6-3-外存分配方式" class="headerlink" title="6.3 外存分配方式"></a>6.3 外存分配方式</h2><h2 id="6-4-目录管理"><a href="#6-4-目录管理" class="headerlink" title="6.4 目录管理"></a>6.4 目录管理</h2><h2 id="6-5-文件存储空间的管理"><a href="#6-5-文件存储空间的管理" class="headerlink" title="6.5 文件存储空间的管理"></a>6.5 文件存储空间的管理</h2><h2 id="6-6-文件共享与文件保护"><a href="#6-6-文件共享与文件保护" class="headerlink" title="6.6 文件共享与文件保护"></a>6.6 文件共享与文件保护</h2><h2 id="6-7-数据一致性控制"><a href="#6-7-数据一致性控制" class="headerlink" title="6.7 数据一致性控制"></a>6.7 数据一致性控制</h2><h1 id="第七章-操作系统接口"><a href="#第七章-操作系统接口" class="headerlink" title="第七章 操作系统接口"></a>第七章 操作系统接口</h1><h2 id="7-1-联机用户接口"><a href="#7-1-联机用户接口" class="headerlink" title="7.1 联机用户接口"></a>7.1 联机用户接口</h2><h2 id="7-2-Shell命令语言"><a href="#7-2-Shell命令语言" class="headerlink" title="7.2 Shell命令语言"></a>7.2 Shell命令语言</h2><h2 id="7-3-系统调用"><a href="#7-3-系统调用" class="headerlink" title="7.3 系统调用"></a>7.3 系统调用</h2><h2 id="7-4-UNIX系统调用"><a href="#7-4-UNIX系统调用" class="headerlink" title="7.4 UNIX系统调用"></a>7.4 UNIX系统调用</h2><h2 id="7-5-图形用户接口"><a href="#7-5-图形用户接口" class="headerlink" title="7.5 图形用户接口"></a>7.5 图形用户接口</h2><h1 id="第八章-网络操作系统"><a href="#第八章-网络操作系统" class="headerlink" title="第八章 网络操作系统"></a>第八章 网络操作系统</h1><h2 id="8-1-计算机网络概述"><a href="#8-1-计算机网络概述" class="headerlink" title="8.1 计算机网络概述"></a>8.1 计算机网络概述</h2><h2 id="8-2-网络体系结构"><a href="#8-2-网络体系结构" class="headerlink" title="8.2 网络体系结构"></a>8.2 网络体系结构</h2><h2 id="8-3-Internet与Intranet"><a href="#8-3-Internet与Intranet" class="headerlink" title="8.3 Internet与Intranet"></a>8.3 Internet与Intranet</h2><h2 id="8-4-客户，服务器模式"><a href="#8-4-客户，服务器模式" class="headerlink" title="8.4 客户，服务器模式"></a>8.4 客户，服务器模式</h2><h2 id="8-5-网络操作系统的功能"><a href="#8-5-网络操作系统的功能" class="headerlink" title="8.5 网络操作系统的功能"></a>8.5 网络操作系统的功能</h2><h2 id="8-6-网络操作系统提供的服务"><a href="#8-6-网络操作系统提供的服务" class="headerlink" title="8.6 网络操作系统提供的服务"></a>8.6 网络操作系统提供的服务</h2><h1 id="第九章-系统安全性"><a href="#第九章-系统安全性" class="headerlink" title="第九章 系统安全性"></a>第九章 系统安全性</h1><h2 id="9-1-系统安全的基本概念"><a href="#9-1-系统安全的基本概念" class="headerlink" title="9.1 系统安全的基本概念"></a>9.1 系统安全的基本概念</h2><h2 id="9-2-数据加密技术"><a href="#9-2-数据加密技术" class="headerlink" title="9.2 数据加密技术"></a>9.2 数据加密技术</h2><h2 id="9-3-认证技术"><a href="#9-3-认证技术" class="headerlink" title="9.3 认证技术"></a>9.3 认证技术</h2><h2 id="9-4-访问控制技术"><a href="#9-4-访问控制技术" class="headerlink" title="9.4 访问控制技术"></a>9.4 访问控制技术</h2><h2 id="9-5-计算机病毒"><a href="#9-5-计算机病毒" class="headerlink" title="9.5 计算机病毒"></a>9.5 计算机病毒</h2><h1 id="第十章-UNIX系统内核结构"><a href="#第十章-UNIX系统内核结构" class="headerlink" title="第十章 UNIX系统内核结构"></a>第十章 UNIX系统内核结构</h1><h2 id="10-1-UNIX系统概述"><a href="#10-1-UNIX系统概述" class="headerlink" title="10.1 UNIX系统概述"></a>10.1 UNIX系统概述</h2><h2 id="10-2-进程的描述和控制"><a href="#10-2-进程的描述和控制" class="headerlink" title="10.2 进程的描述和控制"></a>10.2 进程的描述和控制</h2><h2 id="10-3-进程的同步与通信"><a href="#10-3-进程的同步与通信" class="headerlink" title="10.3 进程的同步与通信"></a>10.3 进程的同步与通信</h2><h2 id="10-4-存储器管理"><a href="#10-4-存储器管理" class="headerlink" title="10.4 存储器管理"></a>10.4 存储器管理</h2><h2 id="10-5-设备管理"><a href="#10-5-设备管理" class="headerlink" title="10.5 设备管理"></a>10.5 设备管理</h2><h2 id="10-6-文件管理"><a href="#10-6-文件管理" class="headerlink" title="10.6 文件管理"></a>10.6 文件管理</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一章-操作系统引论&quot;&gt;&lt;a href=&quot;#第一章-操作系统引论&quot; class=&quot;headerlink&quot; title=&quot;第一章 操作系统引论&quot;&gt;&lt;/a&gt;第一章 操作系统引论&lt;/h1&gt;&lt;h2 id=&quot;1-1-操作系统的目标和作用&quot;&gt;&lt;a href=&quot;#1-1-操作系
      
    
    </summary>
    
      <category term="01_software_engineering" scheme="https://30s.github.io/categories/01-software-engineering/"/>
    
      <category term="012_operating_system" scheme="https://30s.github.io/categories/01-software-engineering/012-operating-system/"/>
    
    
      <category term="Software Engineering" scheme="https://30s.github.io/tags/Software-Engineering/"/>
    
      <category term="Operating System" scheme="https://30s.github.io/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="https://30s.github.io/2010/09/01/01_software_engineering/013_network/index/"/>
    <id>https://30s.github.io/2010/09/01/01_software_engineering/013_network/index/</id>
    <published>2010-09-01T12:00:00.000Z</published>
    <updated>2018-03-07T13:38:38.170Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第1章-概述"><a href="#第1章-概述" class="headerlink" title="第1章　概述"></a>第1章　概述</h1><h1 id="第2章-物理层"><a href="#第2章-物理层" class="headerlink" title="第2章　物理层"></a>第2章　物理层</h1><h1 id="第3章-数据链路层"><a href="#第3章-数据链路层" class="headerlink" title="第3章　数据链路层"></a>第3章　数据链路层</h1><h1 id="第4章-网络层"><a href="#第4章-网络层" class="headerlink" title="第4章　网络层"></a>第4章　网络层</h1><h1 id="第5章-运输层"><a href="#第5章-运输层" class="headerlink" title="第5章　运输层"></a>第5章　运输层</h1><h1 id="第6章-应用层"><a href="#第6章-应用层" class="headerlink" title="第6章　应用层"></a>第6章　应用层</h1><h1 id="第7章-网络安全"><a href="#第7章-网络安全" class="headerlink" title="第7章　网络安全"></a>第7章　网络安全</h1><h1 id="第8章-因特网上的音频-视频服务"><a href="#第8章-因特网上的音频-视频服务" class="headerlink" title="第8章　因特网上的音频/视频服务"></a>第8章　因特网上的音频/视频服务</h1><h1 id="第9章-无线网络"><a href="#第9章-无线网络" class="headerlink" title="第9章　无线网络"></a>第9章　无线网络</h1><h1 id="第10章-下一代因特网"><a href="#第10章-下一代因特网" class="headerlink" title="第10章　下一代因特网"></a>第10章　下一代因特网</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第1章-概述&quot;&gt;&lt;a href=&quot;#第1章-概述&quot; class=&quot;headerlink&quot; title=&quot;第1章　概述&quot;&gt;&lt;/a&gt;第1章　概述&lt;/h1&gt;&lt;h1 id=&quot;第2章-物理层&quot;&gt;&lt;a href=&quot;#第2章-物理层&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="01_software_engineering" scheme="https://30s.github.io/categories/01-software-engineering/"/>
    
      <category term="013_network" scheme="https://30s.github.io/categories/01-software-engineering/013-network/"/>
    
    
      <category term="Software Engineering" scheme="https://30s.github.io/tags/Software-Engineering/"/>
    
      <category term="Network" scheme="https://30s.github.io/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="https://30s.github.io/2010/09/01/01_software_engineering/014_data_structure/index/"/>
    <id>https://30s.github.io/2010/09/01/01_software_engineering/014_data_structure/index/</id>
    <published>2010-09-01T12:00:00.000Z</published>
    <updated>2018-03-06T10:37:56.830Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第1章-绪论"><a href="#第1章-绪论" class="headerlink" title="第1章 绪论"></a>第1章 绪论</h1><h2 id="1-1-什么是数据结构"><a href="#1-1-什么是数据结构" class="headerlink" title="1.1 什么是数据结构"></a>1.1 什么是数据结构</h2><h2 id="1-2-基本概念和术语"><a href="#1-2-基本概念和术语" class="headerlink" title="1.2 基本概念和术语"></a>1.2 基本概念和术语</h2><h2 id="1-3-抽象数据类型的表现与实现"><a href="#1-3-抽象数据类型的表现与实现" class="headerlink" title="1.3 抽象数据类型的表现与实现"></a>1.3 抽象数据类型的表现与实现</h2><h2 id="1-4-算法和算法分析"><a href="#1-4-算法和算法分析" class="headerlink" title="1.4 算法和算法分析"></a>1.4 算法和算法分析</h2><h1 id="第2章-线性表"><a href="#第2章-线性表" class="headerlink" title="第2章 线性表"></a>第2章 线性表</h1><h2 id="2-1-线性表的类型定义"><a href="#2-1-线性表的类型定义" class="headerlink" title="2.1 线性表的类型定义"></a>2.1 线性表的类型定义</h2><h2 id="2-2-线性表的顺序表示和实现"><a href="#2-2-线性表的顺序表示和实现" class="headerlink" title="2.2 线性表的顺序表示和实现"></a>2.2 线性表的顺序表示和实现</h2><h2 id="2-3-线性表的链式表示和实现"><a href="#2-3-线性表的链式表示和实现" class="headerlink" title="2.3 线性表的链式表示和实现"></a>2.3 线性表的链式表示和实现</h2><h2 id="2-4-一元多项式的表示及相加"><a href="#2-4-一元多项式的表示及相加" class="headerlink" title="2.4 一元多项式的表示及相加"></a>2.4 一元多项式的表示及相加</h2><h1 id="第3章-栈和队列"><a href="#第3章-栈和队列" class="headerlink" title="第3章 栈和队列"></a>第3章 栈和队列</h1><h2 id="3-1-栈"><a href="#3-1-栈" class="headerlink" title="3.1 栈"></a>3.1 栈</h2><h2 id="3-2-栈的应有和举例"><a href="#3-2-栈的应有和举例" class="headerlink" title="3.2 栈的应有和举例"></a>3.2 栈的应有和举例</h2><h2 id="3-3-栈与递归的实现"><a href="#3-3-栈与递归的实现" class="headerlink" title="3.3 栈与递归的实现"></a>3.3 栈与递归的实现</h2><h2 id="3-4-队列"><a href="#3-4-队列" class="headerlink" title="3.4 队列"></a>3.4 队列</h2><h2 id="3-5-离散事件模拟"><a href="#3-5-离散事件模拟" class="headerlink" title="3.5 离散事件模拟"></a>3.5 离散事件模拟</h2><h1 id="第4章-串"><a href="#第4章-串" class="headerlink" title="第4章 串"></a>第4章 串</h1><h2 id="4-1-串类型的定义"><a href="#4-1-串类型的定义" class="headerlink" title="4.1 串类型的定义"></a>4.1 串类型的定义</h2><h2 id="4-2-串的表示和实现"><a href="#4-2-串的表示和实现" class="headerlink" title="4.2 串的表示和实现"></a>4.2 串的表示和实现</h2><h2 id="4-3-串的模式匹配算法"><a href="#4-3-串的模式匹配算法" class="headerlink" title="4.3 串的模式匹配算法"></a>4.3 串的模式匹配算法</h2><h2 id="4-4-串操作应用举例"><a href="#4-4-串操作应用举例" class="headerlink" title="4.4 串操作应用举例"></a>4.4 串操作应用举例</h2><h1 id="第5章-数组和广义表"><a href="#第5章-数组和广义表" class="headerlink" title="第5章 数组和广义表"></a>第5章 数组和广义表</h1><h2 id="5-1-数组的定义"><a href="#5-1-数组的定义" class="headerlink" title="5.1 数组的定义"></a>5.1 数组的定义</h2><h2 id="5-2-数组的顺序表现和实现"><a href="#5-2-数组的顺序表现和实现" class="headerlink" title="5.2 数组的顺序表现和实现"></a>5.2 数组的顺序表现和实现</h2><h2 id="5-3-矩阵的压缩存储"><a href="#5-3-矩阵的压缩存储" class="headerlink" title="5.3 矩阵的压缩存储"></a>5.3 矩阵的压缩存储</h2><h2 id="5-4-广义表的定义"><a href="#5-4-广义表的定义" class="headerlink" title="5.4 广义表的定义"></a>5.4 广义表的定义</h2><h2 id="5-5-广义表的储存结构"><a href="#5-5-广义表的储存结构" class="headerlink" title="5.5 广义表的储存结构"></a>5.5 广义表的储存结构</h2><h2 id="5-6-m元多项式的表示"><a href="#5-6-m元多项式的表示" class="headerlink" title="5.6 m元多项式的表示"></a>5.6 m元多项式的表示</h2><h2 id="5-7-广义表的递归算法"><a href="#5-7-广义表的递归算法" class="headerlink" title="5.7 广义表的递归算法"></a>5.7 广义表的递归算法</h2><h1 id="第6章-树和二叉树"><a href="#第6章-树和二叉树" class="headerlink" title="第6章 树和二叉树"></a>第6章 树和二叉树</h1><h2 id="6-1-树的定义和基本术语"><a href="#6-1-树的定义和基本术语" class="headerlink" title="6.1 树的定义和基本术语"></a>6.1 树的定义和基本术语</h2><h2 id="6-2-二叉树"><a href="#6-2-二叉树" class="headerlink" title="6.2 二叉树"></a>6.2 二叉树</h2><h3 id="6-2-1-二叉树的定义"><a href="#6-2-1-二叉树的定义" class="headerlink" title="6.2.1 二叉树的定义"></a>6.2.1 二叉树的定义</h3><h3 id="6-2-2-二叉树的性质"><a href="#6-2-2-二叉树的性质" class="headerlink" title="6.2.2 二叉树的性质"></a>6.2.2 二叉树的性质</h3><h3 id="6-2-3-二叉树的存储结构"><a href="#6-2-3-二叉树的存储结构" class="headerlink" title="6.2.3 二叉树的存储结构"></a>6.2.3 二叉树的存储结构</h3><h2 id="6-3-遍历二叉树和线索二叉树"><a href="#6-3-遍历二叉树和线索二叉树" class="headerlink" title="6.3 遍历二叉树和线索二叉树"></a>6.3 遍历二叉树和线索二叉树</h2><h3 id="6-3-1-遍历二叉树"><a href="#6-3-1-遍历二叉树" class="headerlink" title="6.3.1 遍历二叉树"></a>6.3.1 遍历二叉树</h3><h3 id="6-3-2-线索二叉树"><a href="#6-3-2-线索二叉树" class="headerlink" title="6.3.2 线索二叉树"></a>6.3.2 线索二叉树</h3><h2 id="6-4-树和森林"><a href="#6-4-树和森林" class="headerlink" title="6.4 树和森林"></a>6.4 树和森林</h2><h3 id="6-4-1-树的存储结构"><a href="#6-4-1-树的存储结构" class="headerlink" title="6.4.1 树的存储结构"></a>6.4.1 树的存储结构</h3><h3 id="6-4-2-森林与二叉树的转换"><a href="#6-4-2-森林与二叉树的转换" class="headerlink" title="6.4.2 森林与二叉树的转换"></a>6.4.2 森林与二叉树的转换</h3><h3 id="6-4-3-树和森林的遍历"><a href="#6-4-3-树和森林的遍历" class="headerlink" title="6.4.3 树和森林的遍历"></a>6.4.3 树和森林的遍历</h3><h2 id="6-5-树与等价问题"><a href="#6-5-树与等价问题" class="headerlink" title="6.5 树与等价问题"></a>6.5 树与等价问题</h2><h2 id="6-6-赫夫曼树及其应用"><a href="#6-6-赫夫曼树及其应用" class="headerlink" title="6.6 赫夫曼树及其应用"></a>6.6 赫夫曼树及其应用</h2><h3 id="6-6-1-最优二叉树-赫夫曼树"><a href="#6-6-1-最优二叉树-赫夫曼树" class="headerlink" title="### 6.6.1 最优二叉树(赫夫曼树)"></a>### 6.6.1 最优二叉树(赫夫曼树)</h3><h3 id="6-6-2-赫夫曼编码"><a href="#6-6-2-赫夫曼编码" class="headerlink" title="6.6.2 赫夫曼编码"></a>6.6.2 赫夫曼编码</h3><h2 id="6-7-回溯法与树的遍历"><a href="#6-7-回溯法与树的遍历" class="headerlink" title="6.7 回溯法与树的遍历"></a>6.7 回溯法与树的遍历</h2><h2 id="6-8-树的计数"><a href="#6-8-树的计数" class="headerlink" title="6.8 树的计数"></a>6.8 树的计数</h2><h1 id="第7章-图"><a href="#第7章-图" class="headerlink" title="第7章 图"></a>第7章 图</h1><h2 id="7-1-图的定义和术语"><a href="#7-1-图的定义和术语" class="headerlink" title="7.1 图的定义和术语"></a>7.1 图的定义和术语</h2><h2 id="7-2-图的存储结构"><a href="#7-2-图的存储结构" class="headerlink" title="7.2 图的存储结构"></a>7.2 图的存储结构</h2><h3 id="7-2-1-数组表示法"><a href="#7-2-1-数组表示法" class="headerlink" title="7.2.1 数组表示法"></a>7.2.1 数组表示法</h3><h3 id="7-2-2-邻接表"><a href="#7-2-2-邻接表" class="headerlink" title="7.2.2 邻接表"></a>7.2.2 邻接表</h3><h3 id="7-2-3-十字链表"><a href="#7-2-3-十字链表" class="headerlink" title="7.2.3 十字链表"></a>7.2.3 十字链表</h3><h3 id="7-2-4-邻接多重表"><a href="#7-2-4-邻接多重表" class="headerlink" title="7.2.4 邻接多重表"></a>7.2.4 邻接多重表</h3><h2 id="7-3-图的遍历"><a href="#7-3-图的遍历" class="headerlink" title="7.3 图的遍历"></a>7.3 图的遍历</h2><h3 id="7-3-1-深度优先搜索"><a href="#7-3-1-深度优先搜索" class="headerlink" title="7.3.1 深度优先搜索"></a>7.3.1 深度优先搜索</h3><h3 id="7-3-2-广度优先搜索"><a href="#7-3-2-广度优先搜索" class="headerlink" title="7.3.2 广度优先搜索"></a>7.3.2 广度优先搜索</h3><h2 id="7-4-图的连通性问题"><a href="#7-4-图的连通性问题" class="headerlink" title="7.4 图的连通性问题"></a>7.4 图的连通性问题</h2><h3 id="7-4-1-无向图的连通分量和生成树"><a href="#7-4-1-无向图的连通分量和生成树" class="headerlink" title="7.4.1 无向图的连通分量和生成树"></a>7.4.1 无向图的连通分量和生成树</h3><h3 id="7-4-2-有向图的强连通分量"><a href="#7-4-2-有向图的强连通分量" class="headerlink" title="7.4.2 有向图的强连通分量"></a>7.4.2 有向图的强连通分量</h3><h3 id="7-4-3-最小生成树"><a href="#7-4-3-最小生成树" class="headerlink" title="7.4.3 最小生成树"></a>7.4.3 最小生成树</h3><h3 id="7-4-4-关节点和重连通分量"><a href="#7-4-4-关节点和重连通分量" class="headerlink" title="7.4.4 关节点和重连通分量"></a>7.4.4 关节点和重连通分量</h3><h2 id="7-5-有向无环图及其应用"><a href="#7-5-有向无环图及其应用" class="headerlink" title="7.5 有向无环图及其应用"></a>7.5 有向无环图及其应用</h2><h3 id="7-5-1-拓扑排序"><a href="#7-5-1-拓扑排序" class="headerlink" title="7.5.1 拓扑排序"></a>7.5.1 拓扑排序</h3><h3 id="7-5-2-关键路径"><a href="#7-5-2-关键路径" class="headerlink" title="7.5.2 关键路径"></a>7.5.2 关键路径</h3><h2 id="7-6-最短路径"><a href="#7-6-最短路径" class="headerlink" title="7.6 最短路径"></a>7.6 最短路径</h2><h3 id="7-6-1-从某个源点到其余各顶点的最短路径"><a href="#7-6-1-从某个源点到其余各顶点的最短路径" class="headerlink" title="7.6.1 从某个源点到其余各顶点的最短路径"></a>7.6.1 从某个源点到其余各顶点的最短路径</h3><h3 id="7-6-2-每一对顶点之间的最短路径"><a href="#7-6-2-每一对顶点之间的最短路径" class="headerlink" title="7.6.2 每一对顶点之间的最短路径"></a>7.6.2 每一对顶点之间的最短路径</h3><h1 id="第8章-动态存储管理"><a href="#第8章-动态存储管理" class="headerlink" title="第8章 动态存储管理"></a>第8章 动态存储管理</h1><h2 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h2><h2 id="8-2-可利用空间表及分配方法"><a href="#8-2-可利用空间表及分配方法" class="headerlink" title="8.2 可利用空间表及分配方法"></a>8.2 可利用空间表及分配方法</h2><h2 id="8-3-边界标识法"><a href="#8-3-边界标识法" class="headerlink" title="8.3 边界标识法"></a>8.3 边界标识法</h2><h3 id="8-3-1-可利用空间表的结构"><a href="#8-3-1-可利用空间表的结构" class="headerlink" title="8.3.1 可利用空间表的结构"></a>8.3.1 可利用空间表的结构</h3><h3 id="8-3-2-分配算法"><a href="#8-3-2-分配算法" class="headerlink" title="8.3.2 分配算法"></a>8.3.2 分配算法</h3><h3 id="8-3-3-回收算法"><a href="#8-3-3-回收算法" class="headerlink" title="8.3.3 回收算法"></a>8.3.3 回收算法</h3><h2 id="8-4-伙伴系统"><a href="#8-4-伙伴系统" class="headerlink" title="8.4 伙伴系统"></a>8.4 伙伴系统</h2><h3 id="8-4-1-可利用空间表的结构"><a href="#8-4-1-可利用空间表的结构" class="headerlink" title="8.4.1 可利用空间表的结构"></a>8.4.1 可利用空间表的结构</h3><h3 id="8-4-2-分配算法"><a href="#8-4-2-分配算法" class="headerlink" title="8.4.2 分配算法"></a>8.4.2 分配算法</h3><h3 id="8-4-3-回收算法"><a href="#8-4-3-回收算法" class="headerlink" title="8.4.3 回收算法"></a>8.4.3 回收算法</h3><h2 id="8-5-无用单元收集"><a href="#8-5-无用单元收集" class="headerlink" title="8.5 无用单元收集"></a>8.5 无用单元收集</h2><h2 id="8-6-存储紧缩"><a href="#8-6-存储紧缩" class="headerlink" title="8.6 存储紧缩"></a>8.6 存储紧缩</h2><h1 id="第9章-查找"><a href="#第9章-查找" class="headerlink" title="第9章 查找"></a>第9章 查找</h1><h2 id="9-1-静态查找表"><a href="#9-1-静态查找表" class="headerlink" title="9.1 静态查找表"></a>9.1 静态查找表</h2><h3 id="9-1-1-顺序表的查找"><a href="#9-1-1-顺序表的查找" class="headerlink" title="9.1.1 顺序表的查找"></a>9.1.1 顺序表的查找</h3><h3 id="9-1-2-有序表的查找"><a href="#9-1-2-有序表的查找" class="headerlink" title="9.1.2 有序表的查找"></a>9.1.2 有序表的查找</h3><h3 id="9-1-3-静态树表的查找"><a href="#9-1-3-静态树表的查找" class="headerlink" title="9.1.3 静态树表的查找"></a>9.1.3 静态树表的查找</h3><h3 id="9-1-4-索引顺序表的查找"><a href="#9-1-4-索引顺序表的查找" class="headerlink" title="9.1.4 索引顺序表的查找"></a>9.1.4 索引顺序表的查找</h3><h2 id="9-2-动态查找表"><a href="#9-2-动态查找表" class="headerlink" title="9.2 动态查找表"></a>9.2 动态查找表</h2><h3 id="9-2-1-二叉排序树和平衡二叉树"><a href="#9-2-1-二叉排序树和平衡二叉树" class="headerlink" title="9.2.1 二叉排序树和平衡二叉树"></a>9.2.1 二叉排序树和平衡二叉树</h3><h3 id="9-2-2-B树和B-树"><a href="#9-2-2-B树和B-树" class="headerlink" title="9.2.2 B树和B+树"></a>9.2.2 B树和B+树</h3><h3 id="9-2-3-键树"><a href="#9-2-3-键树" class="headerlink" title="9.2.3 键树"></a>9.2.3 键树</h3><h2 id="9-3-哈希表"><a href="#9-3-哈希表" class="headerlink" title="9.3 哈希表"></a>9.3 哈希表</h2><h3 id="9-3-1-什么是哈希表"><a href="#9-3-1-什么是哈希表" class="headerlink" title="9.3.1 什么是哈希表"></a>9.3.1 什么是哈希表</h3><h3 id="9-3-2-哈希函数的构造方法"><a href="#9-3-2-哈希函数的构造方法" class="headerlink" title="9.3.2 哈希函数的构造方法"></a>9.3.2 哈希函数的构造方法</h3><h3 id="9-3-3-处理冲突的方法"><a href="#9-3-3-处理冲突的方法" class="headerlink" title="9.3.3 处理冲突的方法"></a>9.3.3 处理冲突的方法</h3><h3 id="9-3-4-哈希表的查找及其分析"><a href="#9-3-4-哈希表的查找及其分析" class="headerlink" title="9.3.4 哈希表的查找及其分析"></a>9.3.4 哈希表的查找及其分析</h3><h1 id="第10章-内部排序"><a href="#第10章-内部排序" class="headerlink" title="第10章 内部排序"></a>第10章 内部排序</h1><h2 id="10-1-概述"><a href="#10-1-概述" class="headerlink" title="10.1 概述"></a>10.1 概述</h2><h2 id="10-2-插入排序"><a href="#10-2-插入排序" class="headerlink" title="10.2 插入排序"></a>10.2 插入排序</h2><h3 id="10-2-1-直接插入排序"><a href="#10-2-1-直接插入排序" class="headerlink" title="10.2.1 直接插入排序"></a>10.2.1 直接插入排序</h3><h3 id="10-2-2-其他插入排序"><a href="#10-2-2-其他插入排序" class="headerlink" title="10.2.2 其他插入排序"></a>10.2.2 其他插入排序</h3><h3 id="10-2-3-希尔排序"><a href="#10-2-3-希尔排序" class="headerlink" title="10.2.3 希尔排序"></a>10.2.3 希尔排序</h3><h2 id="10-3-快速排序"><a href="#10-3-快速排序" class="headerlink" title="10.3 快速排序"></a>10.3 快速排序</h2><h2 id="10-4-选择排序"><a href="#10-4-选择排序" class="headerlink" title="10.4 选择排序"></a>10.4 选择排序</h2><h3 id="10-4-1-简单选择排序"><a href="#10-4-1-简单选择排序" class="headerlink" title="10.4.1 简单选择排序"></a>10.4.1 简单选择排序</h3><h3 id="10-4-2-树形选择排序"><a href="#10-4-2-树形选择排序" class="headerlink" title="10.4.2 树形选择排序"></a>10.4.2 树形选择排序</h3><h3 id="10-4-3-堆排序"><a href="#10-4-3-堆排序" class="headerlink" title="10.4.3 堆排序"></a>10.4.3 堆排序</h3><h2 id="10-5-归并排序"><a href="#10-5-归并排序" class="headerlink" title="10.5 归并排序"></a>10.5 归并排序</h2><h2 id="10-6-基数排序"><a href="#10-6-基数排序" class="headerlink" title="10.6 基数排序"></a>10.6 基数排序</h2><h3 id="10-6-1-多关键字的排序"><a href="#10-6-1-多关键字的排序" class="headerlink" title="10.6.1 多关键字的排序"></a>10.6.1 多关键字的排序</h3><h3 id="10-6-2-链式基数排序"><a href="#10-6-2-链式基数排序" class="headerlink" title="10.6.2 链式基数排序"></a>10.6.2 链式基数排序</h3><h2 id="10-7-各种内部排序方法的比较讨论"><a href="#10-7-各种内部排序方法的比较讨论" class="headerlink" title="10.7 各种内部排序方法的比较讨论"></a>10.7 各种内部排序方法的比较讨论</h2><h1 id="第11章-外部排序"><a href="#第11章-外部排序" class="headerlink" title="第11章 外部排序"></a>第11章 外部排序</h1><h2 id="11-1-外存信息的存取"><a href="#11-1-外存信息的存取" class="headerlink" title="11.1 外存信息的存取"></a>11.1 外存信息的存取</h2><h2 id="11-2-外部排序的方法"><a href="#11-2-外部排序的方法" class="headerlink" title="11.2 外部排序的方法"></a>11.2 外部排序的方法</h2><h2 id="11-3-多路平衡归并的实现"><a href="#11-3-多路平衡归并的实现" class="headerlink" title="11.3 多路平衡归并的实现"></a>11.3 多路平衡归并的实现</h2><h2 id="11-4-置换一选择排序"><a href="#11-4-置换一选择排序" class="headerlink" title="11.4 置换一选择排序"></a>11.4 置换一选择排序</h2><h2 id="11-5-最佳归并树"><a href="#11-5-最佳归并树" class="headerlink" title="11.5 最佳归并树"></a>11.5 最佳归并树</h2><h1 id="第12章-文件"><a href="#第12章-文件" class="headerlink" title="第12章 文件"></a>第12章 文件</h1><h2 id="12-1-有关文件的基本概念"><a href="#12-1-有关文件的基本概念" class="headerlink" title="12.1 有关文件的基本概念"></a>12.1 有关文件的基本概念</h2><h2 id="12-2-顺序文件"><a href="#12-2-顺序文件" class="headerlink" title="12.2 顺序文件"></a>12.2 顺序文件</h2><h2 id="12-3-索引文件"><a href="#12-3-索引文件" class="headerlink" title="12.3 索引文件"></a>12.3 索引文件</h2><h2 id="12-4-ISAM文件和VSAM文件"><a href="#12-4-ISAM文件和VSAM文件" class="headerlink" title="12.4 ISAM文件和VSAM文件"></a>12.4 ISAM文件和VSAM文件</h2><h3 id="12-4-1-ISAM文件"><a href="#12-4-1-ISAM文件" class="headerlink" title="12.4.1 ISAM文件"></a>12.4.1 ISAM文件</h3><h3 id="12-4-2-VSAM文件"><a href="#12-4-2-VSAM文件" class="headerlink" title="12.4.2 VSAM文件"></a>12.4.2 VSAM文件</h3><h2 id="12-5-直接存取文件-散列文件"><a href="#12-5-直接存取文件-散列文件" class="headerlink" title="12.5 直接存取文件(散列文件)"></a>12.5 直接存取文件(散列文件)</h2><h2 id="12-6-多关键字文件"><a href="#12-6-多关键字文件" class="headerlink" title="12.6 多关键字文件"></a>12.6 多关键字文件</h2><h3 id="12-6-1-多重表文件"><a href="#12-6-1-多重表文件" class="headerlink" title="12.6.1 多重表文件"></a>12.6.1 多重表文件</h3><h3 id="12-6-2-倒排文件"><a href="#12-6-2-倒排文件" class="headerlink" title="12.6.2 倒排文件"></a>12.6.2 倒排文件</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第1章-绪论&quot;&gt;&lt;a href=&quot;#第1章-绪论&quot; class=&quot;headerlink&quot; title=&quot;第1章 绪论&quot;&gt;&lt;/a&gt;第1章 绪论&lt;/h1&gt;&lt;h2 id=&quot;1-1-什么是数据结构&quot;&gt;&lt;a href=&quot;#1-1-什么是数据结构&quot; class=&quot;header
      
    
    </summary>
    
      <category term="01_software_engineering" scheme="https://30s.github.io/categories/01-software-engineering/"/>
    
      <category term="014_data_structure" scheme="https://30s.github.io/categories/01-software-engineering/014-data-structure/"/>
    
    
      <category term="Software Engineering" scheme="https://30s.github.io/tags/Software-Engineering/"/>
    
      <category term="Data Structure" scheme="https://30s.github.io/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析</title>
    <link href="https://30s.github.io/2010/09/01/01_software_engineering/015_algorithm/index/"/>
    <id>https://30s.github.io/2010/09/01/01_software_engineering/015_algorithm/index/</id>
    <published>2010-09-01T12:00:00.000Z</published>
    <updated>2018-03-06T10:40:00.753Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第1章-算法概述"><a href="#第1章-算法概述" class="headerlink" title="第1章　算法概述"></a>第1章　算法概述</h1><h2 id="1-1-算法与程序"><a href="#1-1-算法与程序" class="headerlink" title="1.1　算法与程序"></a>1.1　算法与程序</h2><h2 id="1-2-算法复杂性分析"><a href="#1-2-算法复杂性分析" class="headerlink" title="1.2　算法复杂性分析"></a>1.2　算法复杂性分析</h2><h1 id="第2章-递归与分治策略"><a href="#第2章-递归与分治策略" class="headerlink" title="第2章　递归与分治策略"></a>第2章　递归与分治策略</h1><h2 id="2-1-递归的概念"><a href="#2-1-递归的概念" class="headerlink" title="2.1　递归的概念"></a>2.1　递归的概念</h2><h2 id="2-2-分治法的基本思想"><a href="#2-2-分治法的基本思想" class="headerlink" title="2.2　分治法的基本思想"></a>2.2　分治法的基本思想</h2><h2 id="2-3-二分搜索技术"><a href="#2-3-二分搜索技术" class="headerlink" title="2.3　二分搜索技术"></a>2.3　二分搜索技术</h2><h2 id="2-4-大整数的乘法"><a href="#2-4-大整数的乘法" class="headerlink" title="2.4　大整数的乘法"></a>2.4　大整数的乘法</h2><h2 id="2-5-Strassen矩阵乘法"><a href="#2-5-Strassen矩阵乘法" class="headerlink" title="2.5　Strassen矩阵乘法"></a>2.5　Strassen矩阵乘法</h2><h2 id="2-6-棋盘覆盖"><a href="#2-6-棋盘覆盖" class="headerlink" title="2.6　棋盘覆盖"></a>2.6　棋盘覆盖</h2><h2 id="2-7-合并排序"><a href="#2-7-合并排序" class="headerlink" title="2.7　合并排序"></a>2.7　合并排序</h2><h2 id="2-8-快速排序"><a href="#2-8-快速排序" class="headerlink" title="2.8　快速排序"></a>2.8　快速排序</h2><h2 id="2-9-线性时间选择"><a href="#2-9-线性时间选择" class="headerlink" title="2.9　线性时间选择"></a>2.9　线性时间选择</h2><h2 id="2-10-最接近点对问题"><a href="#2-10-最接近点对问题" class="headerlink" title="2.10　最接近点对问题"></a>2.10　最接近点对问题</h2><h2 id="2-11-循环赛日程表"><a href="#2-11-循环赛日程表" class="headerlink" title="2.11　循环赛日程表"></a>2.11　循环赛日程表</h2><h1 id="第3章-动态规划"><a href="#第3章-动态规划" class="headerlink" title="第3章　动态规划"></a>第3章　动态规划</h1><h2 id="3-1-矩阵连乘问题"><a href="#3-1-矩阵连乘问题" class="headerlink" title="3.1　矩阵连乘问题"></a>3.1　矩阵连乘问题</h2><h2 id="3-2-动态规划算法的基本要素"><a href="#3-2-动态规划算法的基本要素" class="headerlink" title="3.2　动态规划算法的基本要素"></a>3.2　动态规划算法的基本要素</h2><h2 id="3-3-最长公共子序列"><a href="#3-3-最长公共子序列" class="headerlink" title="3.3　最长公共子序列"></a>3.3　最长公共子序列</h2><h2 id="3-4-最大子段和"><a href="#3-4-最大子段和" class="headerlink" title="3.4　最大子段和"></a>3.4　最大子段和</h2><h2 id="3-5-凸多边形最优三角剖分"><a href="#3-5-凸多边形最优三角剖分" class="headerlink" title="3.5　凸多边形最优三角剖分"></a>3.5　凸多边形最优三角剖分</h2><h2 id="3-6-多边形游戏"><a href="#3-6-多边形游戏" class="headerlink" title="3.6　多边形游戏"></a>3.6　多边形游戏</h2><h2 id="3-7-图像压缩"><a href="#3-7-图像压缩" class="headerlink" title="3.7　图像压缩"></a>3.7　图像压缩</h2><h2 id="3-8-电路布线"><a href="#3-8-电路布线" class="headerlink" title="3.8　电路布线"></a>3.8　电路布线</h2><h2 id="3-9-流水作业调度"><a href="#3-9-流水作业调度" class="headerlink" title="3.9　流水作业调度"></a>3.9　流水作业调度</h2><h2 id="3-10-0-1背包问题"><a href="#3-10-0-1背包问题" class="headerlink" title="3.10　0-1背包问题"></a>3.10　0-1背包问题</h2><h2 id="3-11-最优二叉搜索树"><a href="#3-11-最优二叉搜索树" class="headerlink" title="3.11　最优二叉搜索树"></a>3.11　最优二叉搜索树</h2><h2 id="3-12-动态规划加速原理"><a href="#3-12-动态规划加速原理" class="headerlink" title="3.12　动态规划加速原理"></a>3.12　动态规划加速原理</h2><h1 id="第4章-贪心算法"><a href="#第4章-贪心算法" class="headerlink" title="第4章　贪心算法"></a>第4章　贪心算法</h1><h1 id="第5章-回溯法"><a href="#第5章-回溯法" class="headerlink" title="第5章　回溯法"></a>第5章　回溯法</h1><h1 id="第6章-分支限界法"><a href="#第6章-分支限界法" class="headerlink" title="第6章　分支限界法"></a>第6章　分支限界法</h1><h1 id="第7章-随机化算法"><a href="#第7章-随机化算法" class="headerlink" title="第7章　随机化算法"></a>第7章　随机化算法</h1><h1 id="第8章-线性规划与网络流"><a href="#第8章-线性规划与网络流" class="headerlink" title="第8章　线性规划与网络流"></a>第8章　线性规划与网络流</h1><h1 id="第9章-NP完全性理论与近似算法"><a href="#第9章-NP完全性理论与近似算法" class="headerlink" title="第9章　NP完全性理论与近似算法"></a>第9章　NP完全性理论与近似算法</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第1章-算法概述&quot;&gt;&lt;a href=&quot;#第1章-算法概述&quot; class=&quot;headerlink&quot; title=&quot;第1章　算法概述&quot;&gt;&lt;/a&gt;第1章　算法概述&lt;/h1&gt;&lt;h2 id=&quot;1-1-算法与程序&quot;&gt;&lt;a href=&quot;#1-1-算法与程序&quot; class=&quot;he
      
    
    </summary>
    
      <category term="01_software_engineering" scheme="https://30s.github.io/categories/01-software-engineering/"/>
    
      <category term="015_algorithm" scheme="https://30s.github.io/categories/01-software-engineering/015-algorithm/"/>
    
    
      <category term="Software Engineering" scheme="https://30s.github.io/tags/Software-Engineering/"/>
    
      <category term="Algorithm" scheme="https://30s.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>ACM OJ集锦</title>
    <link href="https://30s.github.io/2010/09/01/01_software_engineering/015_algorithm/0151_acm/acm_oj_collection/"/>
    <id>https://30s.github.io/2010/09/01/01_software_engineering/015_algorithm/0151_acm/acm_oj_collection/</id>
    <published>2010-09-01T12:00:00.000Z</published>
    <updated>2018-03-07T12:27:37.258Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ACM-OJ-Collection（排名不分先后）："><a href="#ACM-OJ-Collection（排名不分先后）：" class="headerlink" title="ACM OJ Collection（排名不分先后）："></a>ACM OJ Collection（排名不分先后）：</h1><h2 id="中国：-China"><a href="#中国：-China" class="headerlink" title="中国：(China)"></a>中国：(China)</h2><h3 id="华东地区："><a href="#华东地区：" class="headerlink" title="华东地区："></a>华东地区：</h3><h4 id="浙江："><a href="#浙江：" class="headerlink" title="浙江："></a>浙江：</h4><ul><li>杭州电子科技大学(HDU)：<a href="http://acm.hdu.edu.cn/" target="_blank" rel="noopener">http://acm.hdu.edu.cn/</a></li><li>浙江大学（ZJU）：<a href="http://acm.zju.edu.cn/" target="_blank" rel="noopener">http://acm.zju.edu.cn/</a></li><li>浙江工业大学（ZJUT）：<a href="http://acm.zjut.edu.cn/" target="_blank" rel="noopener">http://acm.zjut.edu.cn/</a></li><li>浙江师范大学（ZJNU）：<a href="http://acm.zjnu.cn/" target="_blank" rel="noopener">http://acm.zjnu.cn/</a></li><li>浙江工商（ZJGSU）：<a href="http://acm.zjgsu.edu.cn/" target="_blank" rel="noopener">http://acm.zjgsu.edu.cn/</a></li><li>宁波理工（NIT）：<a href="http://acm.nit.net.cn/" target="_blank" rel="noopener">http://acm.nit.net.cn/</a></li></ul><h4 id="上海："><a href="#上海：" class="headerlink" title="上海："></a>上海：</h4><ul><li>华东师范大学（ECNU）：<a href="http://acm.cs.ecnu.edu.cn/" target="_blank" rel="noopener">http://acm.cs.ecnu.edu.cn/</a></li><li>华东理工大学（ECUST）：<a href="http://acm.ecust.edu.cn/" target="_blank" rel="noopener">http://acm.ecust.edu.cn/</a></li><li>同济大学（TJU）：<a href="http://acm.tongji.edu.cn/" target="_blank" rel="noopener">http://acm.tongji.edu.cn/</a></li></ul><h4 id="江苏："><a href="#江苏：" class="headerlink" title="江苏："></a>江苏：</h4><ul><li>南京航空航天大学： <a href="http://acm.nuaa.edu.cn/" target="_blank" rel="noopener">http://acm.nuaa.edu.cn/</a></li></ul><h4 id="福建："><a href="#福建：" class="headerlink" title="福建："></a>福建：</h4><ul><li>福州大学（FZU）：<a href="http://acm.fzu.edu.cn/" target="_blank" rel="noopener">http://acm.fzu.edu.cn/</a></li><li>厦门大学（XMU）：<a href="http://acm.xmu.edu.cn/" target="_blank" rel="noopener">http://acm.xmu.edu.cn/</a></li><li>福建师范大学（FJNU）：<a href="http://acm.fjnu.edu.cn/" target="_blank" rel="noopener">http://acm.fjnu.edu.cn/</a></li></ul><h4 id="安徽："><a href="#安徽：" class="headerlink" title="安徽："></a>安徽：</h4><ul><li>中国科技大学（USTC）：<a href="http://acm.ustc.edu.cn/" target="_blank" rel="noopener">http://acm.ustc.edu.cn/</a></li></ul><h3 id="华北地区："><a href="#华北地区：" class="headerlink" title="华北地区："></a>华北地区：</h3><h4 id="北京："><a href="#北京：" class="headerlink" title="北京："></a>北京：</h4><ul><li>北京交大（BJTU）：<a href="http://acm.bjtu.edu.cn/" target="_blank" rel="noopener">http://acm.bjtu.edu.cn/</a></li><li>北京大学（PKU）：<a href="http://acm.pku.edu.cn/" target="_blank" rel="noopener">http://acm.pku.edu.cn/</a></li></ul><h4 id="天津："><a href="#天津：" class="headerlink" title="天津："></a>天津：</h4><ul><li>南开大学（NAIKAI）：<a href="http://acm.nankai.edu.cn/" target="_blank" rel="noopener">http://acm.nankai.edu.cn/</a></li><li>天津大学（TJU）：<a href="http://acm.tju.edu.cn/toj/" target="_blank" rel="noopener">http://acm.tju.edu.cn/toj/</a></li></ul><h3 id="东北地区："><a href="#东北地区：" class="headerlink" title="东北地区："></a>东北地区：</h3><h4 id="黑龙江："><a href="#黑龙江：" class="headerlink" title="黑龙江："></a>黑龙江：</h4><ul><li>哈尔滨工程大学（HRBEU）：<a href="http://acm.hrbeu.edu.cn/" target="_blank" rel="noopener">http://acm.hrbeu.edu.cn/</a></li></ul><h3 id="华南地区："><a href="#华南地区：" class="headerlink" title="华南地区："></a>华南地区：</h3><h4 id="广东："><a href="#广东：" class="headerlink" title="广东："></a>广东：</h4><ul><li>中山大学（ZSU）：<a href="http://acm.zsu.edu.cn/" target="_blank" rel="noopener">http://acm.zsu.edu.cn/</a></li></ul><h3 id="西南地区："><a href="#西南地区：" class="headerlink" title="西南地区："></a>西南地区：</h3><h4 id="四川："><a href="#四川：" class="headerlink" title="四川："></a>四川：</h4><ul><li>西南民大（SWUN）：<a href="http://acm.swun.edu.cn/" target="_blank" rel="noopener">http://acm.swun.edu.cn/</a></li></ul><h3 id="华中地区："><a href="#华中地区：" class="headerlink" title="华中地区："></a>华中地区：</h3><h4 id="湖北："><a href="#湖北：" class="headerlink" title="湖北："></a>湖北：</h4><ul><li>华中科技大学（HUST）：<a href="http://acm.hust.edu.cn/JudgeOnline/" target="_blank" rel="noopener">http://acm.hust.edu.cn/JudgeOnline/</a></li><li>武汉大学（WHU）：<a href="http://acm.whu.edu.cn/" target="_blank" rel="noopener">http://acm.whu.edu.cn/</a></li></ul><h3 id="港澳台地区："><a href="#港澳台地区：" class="headerlink" title="港澳台地区："></a>港澳台地区：</h3><h4 id="香港："><a href="#香港：" class="headerlink" title="香港："></a>香港：</h4><ul><li>香港大学(HKOI)：<a href="http://judge.hkoi.org/" target="_blank" rel="noopener">http://judge.hkoi.org/</a></li></ul><hr><h2 id="俄罗斯：-Russia"><a href="#俄罗斯：-Russia" class="headerlink" title="俄罗斯：(Russia)"></a>俄罗斯：(Russia)</h2><ul><li>乌拉尔大学（URAL）：<a href="http://acm.timus.ru/" target="_blank" rel="noopener">http://acm.timus.ru/</a></li><li>萨拉托夫大学（SGU）：<a href="http://acm.sgu.ru/" target="_blank" rel="noopener">http://acm.sgu.ru/</a></li><li>(vallod) ：<a href="http://acm.uva.es/" target="_blank" rel="noopener">http://acm.uva.es/</a></li><li>EL Judge(MIPT):：<a href="http://acm.mipt.ru/judge/problems.pl" target="_blank" rel="noopener">http://acm.mipt.ru/judge/problems.pl</a></li></ul><hr><h2 id="西班牙：-Spanish"><a href="#西班牙：-Spanish" class="headerlink" title="西班牙：(Spanish)"></a>西班牙：(Spanish)</h2><ul><li>瓦拉杜利德大学（UVA）：<a href="http://acm.uva.es/" target="_blank" rel="noopener">http://acm.uva.es/</a></li></ul><hr><h2 id="美国：-America"><a href="#美国：-America" class="headerlink" title="美国：(America)"></a>美国：(America)</h2><ul><li>USACO: <a href="http://train.usaco.org/usacogate" target="_blank" rel="noopener">http://train.usaco.org/usacogate</a></li></ul><hr><h3 id="波兰：-Poland"><a href="#波兰：-Poland" class="headerlink" title="波兰：(Poland)"></a>波兰：(Poland)</h3><ul><li>SPOJ：<a href="http://www.spoj.pl/" target="_blank" rel="noopener">http://www.spoj.pl/</a></li></ul><hr><h2 id="吉尔吉斯斯坦-：-Kirgizstan"><a href="#吉尔吉斯斯坦-：-Kirgizstan" class="headerlink" title="吉尔吉斯斯坦:：(Kirgizstan)"></a>吉尔吉斯斯坦:：(Kirgizstan)</h2><ul><li>KRSU: <a href="http://www.olymp.krsu.edu.kg/GeneralProblemset.aspx" target="_blank" rel="noopener">http://www.olymp.krsu.edu.kg/GeneralProblemset.aspx</a></li></ul><hr><h2 id="中国各大高校BBS"><a href="#中国各大高校BBS" class="headerlink" title="中国各大高校BBS:"></a>中国各大高校BBS:</h2><ul><li><a href="http://acm.hdu.edu.cn/forum/（杭电）" target="_blank" rel="noopener">http://acm.hdu.edu.cn/forum/（杭电）</a></li><li><a href="http://www.hdubbs.com/（杭电）" target="_blank" rel="noopener">http://www.hdubbs.com/（杭电）</a></li><li><a href="http://www.freecity.cn/（浙大）" target="_blank" rel="noopener">http://www.freecity.cn/（浙大）</a></li><li><a href="http://bbs.freecity.cn/(浙大)" target="_blank" rel="noopener">http://bbs.freecity.cn/(浙大)</a></li></ul><hr><h2 id="Others："><a href="#Others：" class="headerlink" title="Others："></a>Others：</h2><ul><li>Topcoder：<a href="http://www.topcoder.com/tc" target="_blank" rel="noopener">http://www.topcoder.com/tc</a></li><li>ACM-ICPC：<a href="http://icpc.baylor.edu/icpc/" target="_blank" rel="noopener">http://icpc.baylor.edu/icpc/</a></li><li>美国信息学奥林匹克竞赛官方网站：<a href="http://www.usaco.org/" target="_blank" rel="noopener">http://www.usaco.org/</a></li><li>全美计算机奥林匹克竞赛：<a href="http://ace.delos.com/usacogate" target="_blank" rel="noopener">http://ace.delos.com/usacogate</a></li><li>信息学初学者之家：<a href="http://oibh.ioiforum.org/" target="_blank" rel="noopener">http://oibh.ioiforum.org/</a></li><li>中国教育曙光网：<a href="http://www.chinaschool.org/aosai/" target="_blank" rel="noopener">http://www.chinaschool.org/aosai/</a></li><li>福建信息学奥林匹克：<a href="http://www.cfcs.com.cn/fjas/index.htm" target="_blank" rel="noopener">http://www.cfcs.com.cn/fjas/index.htm</a></li><li>IOI：<a href="http://olympiads.win.tue.nl/ioi/" target="_blank" rel="noopener">http://olympiads.win.tue.nl/ioi/</a></li><li>高效信息学在线判题系统（VIJOS）：<a href="http://www.vijos.cn/" target="_blank" rel="noopener">http://www.vijos.cn/</a></li><li>ACM的例程和测试数据：<a href="http://www.karrels.org/Ed/ACM/" target="_blank" rel="noopener">http://www.karrels.org/Ed/ACM/</a></li><li>ACM社区：<a href="http://www.608088.com/" target="_blank" rel="noopener">http://www.608088.com/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ACM-OJ-Collection（排名不分先后）：&quot;&gt;&lt;a href=&quot;#ACM-OJ-Collection（排名不分先后）：&quot; class=&quot;headerlink&quot; title=&quot;ACM OJ Collection（排名不分先后）：&quot;&gt;&lt;/a&gt;ACM OJ C
      
    
    </summary>
    
      <category term="01_software_engineering" scheme="https://30s.github.io/categories/01-software-engineering/"/>
    
      <category term="015_algorithm" scheme="https://30s.github.io/categories/01-software-engineering/015-algorithm/"/>
    
      <category term="0151_acm" scheme="https://30s.github.io/categories/01-software-engineering/015-algorithm/0151-acm/"/>
    
    
      <category term="Software Engineering" scheme="https://30s.github.io/tags/Software-Engineering/"/>
    
      <category term="Algorithm" scheme="https://30s.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>CGLIB(Code Generation Library)详解</title>
    <link href="https://30s.github.io/2010/09/01/02_code_language/022_java/0222_jvm/class_loader/java%E4%B8%AD%E7%9A%84ClassLoader%E8%AF%A6%E8%A7%A3/"/>
    <id>https://30s.github.io/2010/09/01/02_code_language/022_java/0222_jvm/class_loader/java中的ClassLoader详解/</id>
    <published>2010-09-01T05:00:00.000Z</published>
    <updated>2018-03-07T14:51:23.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java中的ClassLoader详解"><a href="#java中的ClassLoader详解" class="headerlink" title="java中的ClassLoader详解"></a>java中的ClassLoader详解</h1><p><a href="http://blog.csdn.net/briblue/article/details/54973413" target="_blank" rel="noopener">http://blog.csdn.net/briblue/article/details/54973413</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java中的ClassLoader详解&quot;&gt;&lt;a href=&quot;#java中的ClassLoader详解&quot; class=&quot;headerlink&quot; title=&quot;java中的ClassLoader详解&quot;&gt;&lt;/a&gt;java中的ClassLoader详解&lt;/h1&gt;&lt;p&gt;&lt;a
      
    
    </summary>
    
      <category term="02_code_language" scheme="https://30s.github.io/categories/02-code-language/"/>
    
      <category term="022_java" scheme="https://30s.github.io/categories/02-code-language/022-java/"/>
    
      <category term="0222_jvm" scheme="https://30s.github.io/categories/02-code-language/022-java/0222-jvm/"/>
    
    
      <category term="Code Language" scheme="https://30s.github.io/tags/Code-Language/"/>
    
      <category term="Java" scheme="https://30s.github.io/tags/Java/"/>
    
      <category term="Jvm" scheme="https://30s.github.io/tags/Jvm/"/>
    
      <category term="ClassLoader" scheme="https://30s.github.io/tags/ClassLoader/"/>
    
  </entry>
  
  <entry>
    <title>CLH队列锁</title>
    <link href="https://30s.github.io/2010/09/01/02_code_language/022_java/0227_concurrent_package/CLH%E9%98%9F%E5%88%97%E9%94%81/"/>
    <id>https://30s.github.io/2010/09/01/02_code_language/022_java/0227_concurrent_package/CLH队列锁/</id>
    <published>2010-09-01T05:00:00.000Z</published>
    <updated>2018-03-12T22:12:47.191Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CLH队列锁"><a href="#CLH队列锁" class="headerlink" title="CLH队列锁"></a>CLH队列锁</h1><p>CLH队列锁<br><a href="http://blog.csdn.net/aesop_wubo/article/details/7533186" target="_blank" rel="noopener">http://blog.csdn.net/aesop_wubo/article/details/7533186</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CLH队列锁&quot;&gt;&lt;a href=&quot;#CLH队列锁&quot; class=&quot;headerlink&quot; title=&quot;CLH队列锁&quot;&gt;&lt;/a&gt;CLH队列锁&lt;/h1&gt;&lt;p&gt;CLH队列锁&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/aesop_wubo/art
      
    
    </summary>
    
      <category term="02_code_language" scheme="https://30s.github.io/categories/02-code-language/"/>
    
      <category term="022_java" scheme="https://30s.github.io/categories/02-code-language/022-java/"/>
    
      <category term="0227_concurrent" scheme="https://30s.github.io/categories/02-code-language/022-java/0227-concurrent/"/>
    
    
      <category term="Code Language" scheme="https://30s.github.io/tags/Code-Language/"/>
    
      <category term="Java" scheme="https://30s.github.io/tags/Java/"/>
    
      <category term="Concurrent" scheme="https://30s.github.io/tags/Concurrent/"/>
    
  </entry>
  
  <entry>
    <title>Java锁优化</title>
    <link href="https://30s.github.io/2010/09/01/02_code_language/022_java/0228_optimize/optimize_lock/Java%E9%94%81%E4%BC%98%E5%8C%96/"/>
    <id>https://30s.github.io/2010/09/01/02_code_language/022_java/0228_optimize/optimize_lock/Java锁优化/</id>
    <published>2010-09-01T05:00:00.000Z</published>
    <updated>2018-03-12T22:14:03.904Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java锁优化"><a href="#Java锁优化" class="headerlink" title="Java锁优化"></a>Java锁优化</h1><p><a href="http://luojinping.com/2015/07/09/java%E9%94%81%E4%BC%98%E5%8C%96/" target="_blank" rel="noopener">原文</a></p><ul><li><h1 id="1-同步的原理"><a href="#1-同步的原理" class="headerlink" title="1. 同步的原理"></a>1. 同步的原理</h1><p>JVM规范规定JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用monitorenter和monitorexit指令实现，而方法同步是使用另外一种方式实现的，细节在JVM规范里并没有详细说明，但是方法的同步同样可以使用这两个指令来实现。monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处， JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个 monitor 与之关联，当且一个monitor 被持有后，它将处于锁定状态。线程执行到 monitorenter 指令时，将会尝试获取对象所对应的 monitor 的所有权，即尝试获得对象的锁。</p><h1 id="2-Java对象头"><a href="#2-Java对象头" class="headerlink" title="2. Java对象头"></a>2. Java对象头</h1><p>锁存在Java对象头里。如果对象是数组类型，则虚拟机用3个Word（字宽）存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，一字宽等于四字节，即32bit。</p><p>| 长度 | 内容 | 说明 |<br>| — | — | — |<br>| 32/64bit | Mark Word | 存储对象的hashCode或锁信息等 |<br>| 32/64bit | Class Metadata Address | 存储到对象类型数据的指针 |<br>| 32/64bit | Array length | 数组的长度（如果当前对象是数组） |</p><p>Java对象头里的Mark Word里默认存储对象的HashCode，分代年龄和锁标记位。32位JVM的Mark Word的默认存储结构如下：</p><p>|   | 25 bit | 4bit | 1bit<br>是否是偏向锁 | 2bit<br>锁标志位 |<br>| — | — | — | — | — |<br>| 无锁状态 | 对象的hashCode | 对象分代年龄 | 0 | 01 |</p><p>在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。Mark Word可能变化为存储以下4种数据：</p><p><a href="http://luojinping.com/img/markword_state.jpg" target="_blank" rel="noopener"><img src="http://luojinping.com/img/markword_state.jpg" alt=""></a></p><h1 id="3-几种锁的类型"><a href="#3-几种锁的类型" class="headerlink" title="3. 几种锁的类型"></a>3. 几种锁的类型</h1><p><strong>线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作。</strong></p><p>Java SE1.6为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在Java SE1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。</p><p><strong>锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。</strong></p><h2 id="3-1-偏向锁"><a href="#3-1-偏向锁" class="headerlink" title="3.1 偏向锁"></a>3.1 偏向锁</h2><p>Hotspot的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。<br><a href="http://luojinping.com/img/biased_lock_flow.jpg" target="_blank" rel="noopener"><img src="http://luojinping.com/img/biased_lock_flow.jpg" alt=""></a></p><h3 id="偏向锁的进一步理解"><a href="#偏向锁的进一步理解" class="headerlink" title="偏向锁的进一步理解"></a>偏向锁的进一步理解</h3><p>偏向锁的释放不需要做任何事情，这也就意味着加过偏向锁的MarkValue会一直保留偏向锁的状态，因此即便同一个线程持续不断地加锁解锁，也是没有开销的。</p><p>另一方面，偏向锁比轻量锁更容易被终结，轻量锁是在有锁竞争出现时升级为重量锁，而一般偏向锁是在有不同线程申请锁时升级为轻量锁，这也就意味着假如一个对象先被线程1加锁解锁，再被线程2加锁解锁，这过程中没有锁冲突，也一样会发生偏向锁失效，不同的是这回要先退化为无锁的状态，再加轻量锁，如图：<br><a href="http://luojinping.com/img/biased_lock_convert_flow.jpg" target="_blank" rel="noopener"><img src="http://luojinping.com/img/biased_lock_convert_flow.jpg" alt=""></a></p><p>另外，JVM对那种会有多线程加锁，但不存在锁竞争的情况也做了优化，听起来比较拗口，但在现实应用中确实是可能出现这种情况，因为线程之前除了互斥之外也可能发生同步关系，被同步的两个线程（一前一后）对共享对象锁的竞争很可能是没有冲突的。对这种情况，JVM用一个epoch表示一个偏向锁的时间戳（真实地生成一个时间戳代价还是蛮大的，因此这里应当理解为一种类似时间戳的identifier），对epoch，官方是这么解释的：</p><blockquote><p>A similar mechanism, called bulk rebiasing, optimizes situations in which objects of a class are locked and unlocked by different threads but never concurrently. It invalidates the bias of all instances of a class without disabling biased locking. An epoch value in the class acts as a timestamp that indicates the validity of the bias. This value is copied into the header word upon object allocation. Bulk rebiasing can then efficiently be implemented as an increment of the epoch in the appropriate class. The next time an instance of this class is going to be locked, the code detects a different value in the header word and rebiases the object towards the current thread.</p></blockquote><h3 id="偏向锁的获取"><a href="#偏向锁的获取" class="headerlink" title="偏向锁的获取"></a>偏向锁的获取</h3><p>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要花费CAS操作来加锁和解锁，而只需简单的测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁，如果测试成功，表示线程已经获得了锁，如果测试失败，则需要再测试下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁），如果没有设置，则使用CAS竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p><h3 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h3><p>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态，如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。下图中的线程1演示了偏向锁初始化的流程，线程2演示了偏向锁撤销的流程。</p><h3 id="偏向锁的设置"><a href="#偏向锁的设置" class="headerlink" title="偏向锁的设置"></a>偏向锁的设置</h3><p>关闭偏向锁：偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟-XX：BiasedLockingStartupDelay = 0。如果你确定自己应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁-XX:-UseBiasedLocking=false，那么默认会进入轻量级锁状态。</p><h2 id="3-2-自旋锁"><a href="#3-2-自旋锁" class="headerlink" title="3.2 自旋锁"></a>3.2 自旋锁</h2><p>线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作。同时我们可以发现，很多对象锁的锁定状态只会持续很短的一段时间，例如整数的自加操作，在很短的时间内阻塞并唤醒线程显然不值得，为此引入了自旋锁。</p><p>所谓“自旋”，就是让线程去执行一个无意义的循环，循环结束后再去重新竞争锁，如果竞争不到继续循环，循环过程中线程会一直处于running状态，但是基于JVM的线程调度，会出让时间片，所以其他线程依旧有申请锁和释放锁的机会。</p><p>自旋锁省去了阻塞锁的时间空间（队列的维护等）开销，但是长时间自旋就变成了“忙式等待”，忙式等待显然还不如阻塞锁。所以自旋的次数一般控制在一个范围内，例如10,100等，在超出这个范围后，自旋锁会升级为阻塞锁。</p><p>对自旋锁周期的选择上，HotSpot认为最佳时间应是一个线程上下文切换的时间，但目前并没有做到。经过调查，目前只是通过汇编暂停了几个CPU周期，除了自旋周期选择，HotSpot还进行许多其他的自旋优化策略，具体如下：</p><ul><li>如果平均负载小于CPUs则一直自旋</li><li>如果有超过(CPUs/2)个线程正在自旋，则后来线程直接阻塞</li><li>如果正在自旋的线程发现Owner发生了变化则延迟自旋时间（自旋计数）或进入阻塞 如果CPU处于节电模式则停止自旋</li><li>自旋时间的最坏情况是CPU的存储延迟（CPU A存储了一个数据，到CPU B得知这个数据直接的时间差）</li></ul><h2 id="3-3-轻量级锁"><a href="#3-3-轻量级锁" class="headerlink" title="3.3 轻量级锁"></a>3.3 轻量级锁</h2><h3 id="轻量级锁加锁"><a href="#轻量级锁加锁" class="headerlink" title="轻量级锁加锁"></a>轻量级锁加锁</h3><p>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。<strong>然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，则自旋获取锁，当自旋获取锁仍然失败时，表示存在其他线程竞争锁(两条或两条以上的线程竞争同一个锁)，则轻量级锁会膨胀成重量级锁。</strong></p><h3 id="轻量级锁解锁"><a href="#轻量级锁解锁" class="headerlink" title="轻量级锁解锁"></a>轻量级锁解锁</h3><p><strong>轻量级解锁时，会使用原子的CAS操作来将Displaced Mark Word替换回到对象头，如果成功，则表示同步过程已完成。</strong>如果失败，表示有其他线程尝试过获取该锁，则要在释放锁的同时唤醒被挂起的线程。下图是两个线程同时争夺锁，导致锁膨胀的流程图。</p><p><a href="http://luojinping.com/img/light_lock_flow.jpg" target="_blank" rel="noopener"><img src="http://luojinping.com/img/light_lock_flow.jpg" alt=""></a><br><a href="http://luojinping.com/img/light_lock_progress.jpg" target="_blank" rel="noopener"><img src="http://luojinping.com/img/light_lock_progress.jpg" alt=""></a></p><h2 id="3-4-重量级锁"><a href="#3-4-重量级锁" class="headerlink" title="3.4 重量级锁"></a>3.4 重量级锁</h2><p>重量锁在JVM中又叫对象监视器（Monitor），它很像C中的Mutex，除了具备Mutex互斥的功能，它还负责实现了Semaphore的功能，也就是说它至少包含一个竞争锁的队列，和一个信号阻塞队列（wait队列），前者负责做互斥，后一个用于做线程同步。</p><h1 id="4-锁的优缺点对比"><a href="#4-锁的优缺点对比" class="headerlink" title="4. 锁的优缺点对比"></a>4. 锁的优缺点对比</h1><p>| 锁 | 优点 | 缺点 | 适用场景 |<br>| — | — | — | — |<br>| 偏向锁 | 加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗 | 适用于只有一个线程访问同步块场景 |<br>| 轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度 | 如果始终得不到锁竞争的线程使用自旋会消耗CPU | 追求响应时间,锁占用时间很短 |<br>| 重量级锁 | 线程竞争不使用自旋，不会消耗CPU | 线程阻塞，响应时间缓慢 | 追求吞吐量,锁占用时间较长 |</p><h1 id="refers"><a href="#refers" class="headerlink" title="refers:"></a>refers:</h1><blockquote><p>周志明的《深入理解Java虚拟机》<br><a href="https://blogs.oracle.com/dave/entry/biased_locking_in_hotspot" target="_blank" rel="noopener">https://blogs.oracle.com/dave/entry/biased_locking_in_hotspot</a><br><a href="https://www.usenix.org/legacy/event/jvm01/full_papers/dice/dice.pdf" target="_blank" rel="noopener">https://www.usenix.org/legacy/event/jvm01/full_papers/dice/dice.pdf</a><br><a href="http://www.javaworld.com/article/2076971/java-concurrency/how-the-java-virtual-machine-performs-thread-synchronization.html" target="_blank" rel="noopener">http://www.javaworld.com/article/2076971/java-concurrency/how-the-java-virtual-machine-performs-thread-synchronization.html</a><br><a href="http://www.infoq.com/cn/articles/java-se-16-synchronized" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/java-se-16-synchronized</a><br><a href="http://www.majin163.com/2014/03/17/synchronized2/" target="_blank" rel="noopener">http://www.majin163.com/2014/03/17/synchronized2/</a><br><a href="http://www.cnblogs.com/javaminer/p/3889023.html" target="_blank" rel="noopener">http://www.cnblogs.com/javaminer/p/3889023.html</a><br><a href="http://blog.csdn.net/coslay/article/details/41526635" target="_blank" rel="noopener">http://blog.csdn.net/coslay/article/details/41526635</a></p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java锁优化&quot;&gt;&lt;a href=&quot;#Java锁优化&quot; class=&quot;headerlink&quot; title=&quot;Java锁优化&quot;&gt;&lt;/a&gt;Java锁优化&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://luojinping.com/2015/07/09/java%E9%
      
    
    </summary>
    
      <category term="02_code_language" scheme="https://30s.github.io/categories/02-code-language/"/>
    
      <category term="022_java" scheme="https://30s.github.io/categories/02-code-language/022-java/"/>
    
      <category term="0228_optimize" scheme="https://30s.github.io/categories/02-code-language/022-java/0228-optimize/"/>
    
    
      <category term="Code Language" scheme="https://30s.github.io/tags/Code-Language/"/>
    
      <category term="Java" scheme="https://30s.github.io/tags/Java/"/>
    
      <category term="Optimize" scheme="https://30s.github.io/tags/Optimize/"/>
    
      <category term="Optimize Lock" scheme="https://30s.github.io/tags/Optimize-Lock/"/>
    
  </entry>
  
  <entry>
    <title>Java中线程池ThreadPoolExecutor原理探究</title>
    <link href="https://30s.github.io/2010/09/01/02_code_language/022_java/0226_thread/thread_pool/Java%E4%B8%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"/>
    <id>https://30s.github.io/2010/09/01/02_code_language/022_java/0226_thread/thread_pool/Java中线程池ThreadPoolExecutor原理探究/</id>
    <published>2010-09-01T05:00:00.000Z</published>
    <updated>2018-03-12T22:12:14.111Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java中线程池ThreadPoolExecutor原理探究"><a href="#Java中线程池ThreadPoolExecutor原理探究" class="headerlink" title="Java中线程池ThreadPoolExecutor原理探究"></a>Java中线程池ThreadPoolExecutor原理探究</h1><ul><li><h1 id="一、-前言"><a href="#一、-前言" class="headerlink" title="一、 前言"></a>一、 前言</h1><p>线程池主要解决两个问题：一方面当执行大量异步任务时候线程池能够提供较好的性能，这是因为使用线程池可以使每个任务的调用开销减少（因为线程池线程是可复用的）。另一方面线程池提供了一种资源限制和管理的手段，比如当执行一系列任务时候对线程的管理，每个ThreadPoolExecutor也保留了一些基本的统计数据，比如当前线程池完成的任务数目。</p><p>另外，线程池提供许多可调参数和可扩展性钩子。程序员可以使用更方便<br>工厂方法比如newCachedThreadPool（无限线程池，线程自动回收），newFixedThreadPool（固定大小的线程池）newSingleThreadExecutor（单个线程），当然用户还可以自定义。</p><h1 id="二、-类图结构"><a href="#二、-类图结构" class="headerlink" title="二、 类图结构"></a>二、 类图结构</h1><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/7b36d810133e8bb624853f5c8e2fd909.jpg" alt="ClassDiagram1.jpg"></p><p>Executors其实是个工具类，里面提供了好多静态方法，根据用户选择返回不同的线程池实例。<br>ThreadPoolExecutor继承了AbstractExecutorService，成员变量ctl是个Integer的原子变量用来记录线程池状态 和 线程池线程个数，类似于ReentrantReadWriteLock使用一个变量存放两种信息。<br>Integer类型是32位二进制标示，其中高3位用来表示线程池状态，后面 29位用来记录线程池线程个数。</p><p><a href="http://ifeve.com/java%E4%B8%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0threadpoolexecutor%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/" target="_blank" rel="noopener">http://ifeve.com/java%E4%B8%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0threadpoolexecutor%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java中线程池ThreadPoolExecutor原理探究&quot;&gt;&lt;a href=&quot;#Java中线程池ThreadPoolExecutor原理探究&quot; class=&quot;headerlink&quot; title=&quot;Java中线程池ThreadPoolExecutor原理探究&quot;&gt;
      
    
    </summary>
    
      <category term="02_code_language" scheme="https://30s.github.io/categories/02-code-language/"/>
    
      <category term="022_java" scheme="https://30s.github.io/categories/02-code-language/022-java/"/>
    
      <category term="0226_thread" scheme="https://30s.github.io/categories/02-code-language/022-java/0226-thread/"/>
    
    
      <category term="Code Language" scheme="https://30s.github.io/tags/Code-Language/"/>
    
      <category term="Java" scheme="https://30s.github.io/tags/Java/"/>
    
      <category term="Thread" scheme="https://30s.github.io/tags/Thread/"/>
    
      <category term="Thread Pool" scheme="https://30s.github.io/tags/Thread-Pool/"/>
    
  </entry>
  
  <entry>
    <title>Java网络教程：ServerSocket</title>
    <link href="https://30s.github.io/2010/09/01/02_code_language/022_java/0225_net/socket/Java%E7%BD%91%E7%BB%9C%E6%95%99%E7%A8%8BServerSocket/"/>
    <id>https://30s.github.io/2010/09/01/02_code_language/022_java/0225_net/socket/Java网络教程ServerSocket/</id>
    <published>2010-09-01T05:00:00.000Z</published>
    <updated>2018-03-12T21:06:19.956Z</updated>
    
    <content type="html"><![CDATA[<ul><li><h3 id="Java网络教程-ServerSocket"><a href="#Java网络教程-ServerSocket" class="headerlink" title="Java网络教程: ServerSocket"></a>Java网络教程: ServerSocket</h3><p><a href="http://tutorials.jenkov.com/java-networking/server-sockets.html" target="_blank" rel="noopener">原文链接</a> 作者：<a href="http://jakob.jenkov.com/" target="_blank" rel="noopener">Jakob Jenkov</a> 译者：homesick</p><p>用java.net.ServerSocket实现java服务通过TCP/IP监听客户端连接，你也可以用Java NIO 来代替java网络标准API，这时候需要用到 ServerSocketChannel。</p><h2 id="创建一个-ServerSocket连接"><a href="#创建一个-ServerSocket连接" class="headerlink" title="创建一个 ServerSocket连接"></a>创建一个 ServerSocket连接</h2><p>以下是一个创建ServerSocket类来监听9000端口的一个简单的代码</p><p>ServerSocket serverSocket = new ServerSocket(9000);</p><h2 id="监听请求的连接"><a href="#监听请求的连接" class="headerlink" title="监听请求的连接"></a>监听请求的连接</h2><p>要获取请求的连接需要用ServerSocket.accept()方法。该方法返回一个Socket类，该类具有普通java Socket类的所有特性。代码如下：</p><p>ServerSocket serverSocket = new ServerSocket(9000); boolean isStopped = false;while(!isStopped){   Socket clientSocket = serverSocket.accept();    //do something with clientSocket}</p><p>对每个调用了accept()方法的类都只获得一个请求的连接。</p><p>另外，请求的连接也只能在线程运行的server中调用了accept()方法之后才能够接受请求。线程运行在server中其它所有的方法上的时候都不能接受客户端的连接请求。所以”接受”请求的线程通常都会把Socket的请求连接放入一个工作线程池中，然后再和客户端连接。更多关于多线程服务端设计的文档请参考 java多线程服务</p><h2 id="关闭客户端Socket"><a href="#关闭客户端Socket" class="headerlink" title="关闭客户端Socket"></a>关闭客户端Socket</h2><p>客户端请求执行完毕，并且不会再有该客户端的其它请求发送过来的时候，就需要关闭Socket连接，这和关闭一个普通的客户端Socket连接一样。如下代码来执行关闭：</p><p>socket.close();</p><h2 id="关闭服务端Sockets"><a href="#关闭服务端Sockets" class="headerlink" title="关闭服务端Sockets"></a>关闭服务端Sockets</h2><p>要关闭服务的时候需要关掉 ServerSocket连接。通过执行如下代码：</p><p>serverSocket.close();</p><p><a href="http://ifeve.com/java-network-serversocket-2/" target="_blank" rel="noopener">http://ifeve.com/java-network-serversocket-2/</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;h3 id=&quot;Java网络教程-ServerSocket&quot;&gt;&lt;a href=&quot;#Java网络教程-ServerSocket&quot; class=&quot;headerlink&quot; title=&quot;Java网络教程: ServerSocket&quot;&gt;&lt;/a&gt;Java网络教程: Ser
      
    
    </summary>
    
      <category term="02_code_language" scheme="https://30s.github.io/categories/02-code-language/"/>
    
      <category term="022_java" scheme="https://30s.github.io/categories/02-code-language/022-java/"/>
    
      <category term="0225_net" scheme="https://30s.github.io/categories/02-code-language/022-java/0225-net/"/>
    
    
      <category term="Code Language" scheme="https://30s.github.io/tags/Code-Language/"/>
    
      <category term="Java" scheme="https://30s.github.io/tags/Java/"/>
    
      <category term="NET" scheme="https://30s.github.io/tags/NET/"/>
    
      <category term="Socket" scheme="https://30s.github.io/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>Java中调度线程池ScheduledThreadPoolExecutor原理探究</title>
    <link href="https://30s.github.io/2010/09/01/02_code_language/022_java/0226_thread/thread_pool/Java%E4%B8%AD%E8%B0%83%E5%BA%A6%E7%BA%BF%E7%A8%8B%E6%B1%A0ScheduledThreadPoolExecutor%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"/>
    <id>https://30s.github.io/2010/09/01/02_code_language/022_java/0226_thread/thread_pool/Java中调度线程池ScheduledThreadPoolExecutor原理探究/</id>
    <published>2010-09-01T05:00:00.000Z</published>
    <updated>2018-03-12T22:12:19.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java中调度线程池ScheduledThreadPoolExecutor原理探究"><a href="#Java中调度线程池ScheduledThreadPoolExecutor原理探究" class="headerlink" title="Java中调度线程池ScheduledThreadPoolExecutor原理探究"></a>Java中调度线程池ScheduledThreadPoolExecutor原理探究</h1><ul><li><h1 id="一、-前言"><a href="#一、-前言" class="headerlink" title="一、 前言"></a>一、 前言</h1><p>前面讲解过Java中线程池ThreadPoolExecutor原理探究，ThreadPoolExecutor是Executors中一部分功能，下面来介绍另外一部分功能也就是ScheduledThreadPoolExecutor的实现，后者是一个可以在一定延迟时候或者定时进行任务调度的线程池。</p><h1 id="二、-类图结构"><a href="#二、-类图结构" class="headerlink" title="二、 类图结构"></a>二、 类图结构</h1><p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/0583c13ae9e056845b5a59ffed185744.jpg" alt="ClassDiagram1.jpg"></p><p>Executors其实是个工具类，里面提供了好多静态方法，根据用户选择返回不同的线程池实例。<br>ScheduledThreadPoolExecutor继承了ThreadPoolExecutor并实现ScheduledExecutorService接口，关于ThreadPoolExecutor的介绍可以参考：<br><a href="http://ifeve.com/java%E4%B8%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0threadpoolexecutor%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/" target="_blank" rel="noopener">http://www.jianshu.com/p/3cc67876375f</a><br>线程池队列是DelayedWorkQueue，它是对delayqueue的优化，关于delayqueue参考：<a href="http://www.jianshu.com/p/2659eb72134b" target="_blank" rel="noopener">http://www.jianshu.com/p/2659eb72134b</a><br>ScheduledFutureTask是阻塞队列元素是对任务修饰。</p><p><a href="http://ifeve.com/33981-2/" target="_blank" rel="noopener">http://ifeve.com/33981-2/</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java中调度线程池ScheduledThreadPoolExecutor原理探究&quot;&gt;&lt;a href=&quot;#Java中调度线程池ScheduledThreadPoolExecutor原理探究&quot; class=&quot;headerlink&quot; title=&quot;Java中调度线程池
      
    
    </summary>
    
      <category term="02_code_language" scheme="https://30s.github.io/categories/02-code-language/"/>
    
      <category term="022_java" scheme="https://30s.github.io/categories/02-code-language/022-java/"/>
    
      <category term="0226_thread" scheme="https://30s.github.io/categories/02-code-language/022-java/0226-thread/"/>
    
    
      <category term="Code Language" scheme="https://30s.github.io/tags/Code-Language/"/>
    
      <category term="Java" scheme="https://30s.github.io/tags/Java/"/>
    
      <category term="Thread" scheme="https://30s.github.io/tags/Thread/"/>
    
      <category term="Thread Pool" scheme="https://30s.github.io/tags/Thread-Pool/"/>
    
  </entry>
  
  <entry>
    <title>Java高并发，如何解决，什么方式解决</title>
    <link href="https://30s.github.io/2010/09/01/02_code_language/022_java/0228_optimize/asynchronous/Java%E9%AB%98%E5%B9%B6%E5%8F%91%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%8C%E4%BB%80%E4%B9%88%E6%96%B9%E5%BC%8F%E8%A7%A3%E5%86%B3/"/>
    <id>https://30s.github.io/2010/09/01/02_code_language/022_java/0228_optimize/asynchronous/Java高并发，如何解决，什么方式解决/</id>
    <published>2010-09-01T05:00:00.000Z</published>
    <updated>2018-03-12T22:13:13.656Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java高并发，如何解决，什么方式解决"><a href="#Java高并发，如何解决，什么方式解决" class="headerlink" title="Java高并发，如何解决，什么方式解决"></a>Java高并发，如何解决，什么方式解决</h1><p><a href="https://www.cnblogs.com/lr393993507/p/5909804.html" target="_blank" rel="noopener">https://www.cnblogs.com/lr393993507/p/5909804.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java高并发，如何解决，什么方式解决&quot;&gt;&lt;a href=&quot;#Java高并发，如何解决，什么方式解决&quot; class=&quot;headerlink&quot; title=&quot;Java高并发，如何解决，什么方式解决&quot;&gt;&lt;/a&gt;Java高并发，如何解决，什么方式解决&lt;/h1&gt;&lt;p&gt;&lt;a
      
    
    </summary>
    
      <category term="02_code_language" scheme="https://30s.github.io/categories/02-code-language/"/>
    
      <category term="022_java" scheme="https://30s.github.io/categories/02-code-language/022-java/"/>
    
      <category term="0228_optimize" scheme="https://30s.github.io/categories/02-code-language/022-java/0228-optimize/"/>
    
    
      <category term="Code Language" scheme="https://30s.github.io/tags/Code-Language/"/>
    
      <category term="Java" scheme="https://30s.github.io/tags/Java/"/>
    
      <category term="Optimize" scheme="https://30s.github.io/tags/Optimize/"/>
    
      <category term="Asynchronous" scheme="https://30s.github.io/tags/Asynchronous/"/>
    
  </entry>
  
  <entry>
    <title>Java高并发异步应用案例</title>
    <link href="https://30s.github.io/2010/09/01/02_code_language/022_java/0228_optimize/asynchronous/Java%E9%AB%98%E5%B9%B6%E5%8F%91%E5%BC%82%E6%AD%A5%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B/"/>
    <id>https://30s.github.io/2010/09/01/02_code_language/022_java/0228_optimize/asynchronous/Java高并发异步应用案例/</id>
    <published>2010-09-01T05:00:00.000Z</published>
    <updated>2018-03-12T22:13:26.514Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java高并发异步应用案例"><a href="#Java高并发异步应用案例" class="headerlink" title="Java高并发异步应用案例"></a>Java高并发异步应用案例</h1><ul><li><h1 id="Java高并发异步应用案例-1"><a href="#Java高并发异步应用案例-1" class="headerlink" title="Java高并发异步应用案例"></a><a href="http://www.cnblogs.com/davidwang456/articles/6548394.html" target="_blank" rel="noopener">Java高并发异步应用案例</a></h1><p>原文地址：<a href="http://chuansong.me/n/355827651252" target="_blank" rel="noopener">http://chuansong.me/n/355827651252</a></p><p>泰康在线微信公众号系泰康在线财产保险股份有限公司旗下平台，希望可以通过持续不断的创新，提升客户对于保险的认知及体验，通过对大数据技术的应用，精准的为客户设计产品以及提供服务。泰康在线微信公众号，现有1000多万粉丝。在日常的运营中，借助于红包奖励、卡券分享、消息通知、微信分享等手段，通过好的内容，好的活动、好的产品以及相应的精准营销来增强用户的粘性和活跃度。</p><p>在日常运营中，公众号会通过给用户下发营销或者科普类的消息来通知客户。 根据经验，微信消息下发后10分钟后流量会逐步上升，30分钟左右到达峰值，1个小时后会显著下降。在这个时间段内，系统的压力会很大。</p><p>在系统设计和改进中，系统的很多场景使用异步进行实现，一方面能缩短主流程的时间处理，另一方面能够通过异步队列进行一定程度的削峰。今天重点介绍单个JVM内的异步优化实践，不涉及分布式时的异步优化实践。在异步执行时，可以调用远程的服务集群来实现一定的任务分解。</p><p>部署示意图</p><p><img src="https://images2017.cnblogs.com/blog/486074/201711/486074-20171123160403008-298152675.png" alt=""></p><p>整个系统都部署在公有云上，虚拟机上有部署1个Nginx，4个Tomcat，Nginx使用随机的方式负载均衡到Tomcat上面。虚机之间通过LB将客户请求转发到Nginx上面负载均衡，Nginx再将请求分配到tomcat应用服务器上。</p><p>由多台应用服务器，对外服务提供Rest服务，在每个Tomcat内部使用异步队列。同时由一台控制服务器，进行异步任务的补偿任务和管理功能。Tomcat和Redis使用多级缓存来降低对Redis的压力，并减少依赖。</p><p>为什么要在虚机上部署Nginx将请求转发到Tomcat，而不是由LB直接转发到Tomcat。这是因为LB能够支持的IP个数是有限的。</p><p>典型的用户场景</p><p><strong>在公众号的运营过程中，典型的事件包括：</strong></p><ul><li><p>发送短信验证码</p></li><li><p>购买成功或者抽奖成功短信通知</p></li><li><p>卡券或优惠券发放</p></li><li><p>发放微信红包</p></li><li><p>微信消息通知</p></li><li><p>订单流程处理</p></li><li><p>定时批处理（比如数据同步）</p></li><li><p>工作流性质的异步任务（未完成异步任务补偿）</p></li></ul><p><strong>面详细说明不同场景能够异步的原因：</strong></p><ol><li><p>不同场景（用户注册，用户购买产品等）下的短信验证码发送，可以使用异步方式发送： 一方面是因为客户这个时效性要求没有那样高，另一方面在特定时间范围内用户没有收到验证码，用户可以点击再次发送验证码。</p></li><li><p>购买成功或者抽奖成功后短信或者邮件通知，可以通过异步的方式进行。 因为涉及用户的利益，要谨慎对待。一方面一定要把数据先存到数据库或者日志里面（注意信息安全^-^,别存敏感明文信息或者加密存储），然后再放入到异步队列中执行。</p><p>另一个方面，要考虑到应用服务意外停止时，没有发送成功数据的补偿机制。 这种情况不常见，并且为了减少耦合和当前异步程序的复杂度。我们使用单独的服务上部署异步任务补偿程序，来扫描未完成的任务，并且进行重放（一定要注意严谨性）。</p></li><li><p>优惠券和卡券的发放，跟购买成功或抽奖成功的方式类似。\u000b可以在当前活动高峰后延时发放，并且使用异步的方式进行。</p></li><li><p>微信红包，因为需要跟微信进行交互，并且微信会通知客户红包的情况，可以使用异步的方式进行。 当涉及资金或者礼品时，一定要谨慎对待设计，并且需要有方便进行异步任务停止和启动的功能。</p></li><li><p>微信消息通知，因为跟微信进行交互，成功后微信进行通知，可以使用异步。 这个跟短信验证码类似。</p></li><li><p>订单流程处理，可以使用异步，因为涉及到后续步骤可以使用简单工作流来完成。有几个开源的框架可以参考。</p></li><li><p>数据同步或者异步任务补偿，因为是延时处理，可以使用异步进行处理。在使用时，可以配合定时任务，比如cron4j来周期性的进行补偿。适合后面总-分-总的任务处理模式。</p></li></ol><p>针对这些“无处不在的异步”，后面详细分析其内在模型。</p><p>无处不在的异步</p><p>下图包含了4种典型的异步队列模型（图片来源于网络）：</p><p><img src="https://images2017.cnblogs.com/blog/486074/201711/486074-20171123160422790-920115059.png" alt=""></p><p>一个生产者生产数据，一个消费者消费数据，一般用在后台处理的业务逻辑中。</p><ul><li><p>一个生产者生产数据，多个消费者消费数据（这里面有两种情况：同一个消息，可以被多个消费者分别消费。或者多个消费者组成一个组，一个消费者消费一个数据）。</p></li><li><p>多个生产者生产数据，单个消费者消费数据，可以用在限流或者排队等候单一资源处理的场景中。</p></li><li><p>多个生产者分别生产数据，多个消费者消费数据（这里面有两种情况：同一个消息，可以被多个消费者分别消费。或者多个消费者组成一个组，一个消费者消费一个数据）。</p></li></ul><p><img src="https://images2017.cnblogs.com/blog/486074/201711/486074-20171123160446477-2129802282.png" alt=""></p><p>总分总任务模型：特别适第一个线程取出一批数据放到队列中（比如select）；由多个线程分别执行业务逻辑；执行后的结果由一个线程来执行（比如update操作，这样能够防止数据库锁）</p><p>这是从技术上分析的几种常见模型，在实践中涉及怎样选择框架。</p><ol><li><p>使用堵塞队列的线程池</p></li><li><p>使用固定步长或固定时间的队列</p></li><li><p>使用Disruptor</p></li><li><p>使用MQ或Kafka</p></li></ol><p><strong>使用线程池实现异步 （支持多生产者，多消费者）</strong></p><p><strong><img src="https://images2017.cnblogs.com/blog/486074/201711/486074-20171123160509040-2040984410.png" alt=""></strong></p><p>特点：可以使用JDK自带的线程池实现异步，编程简单，资料多。建议在并发量小的场景下优先选择。</p><p><strong>使用Guava Queues （支持多生产者单消费者）</strong></p><p><strong><img src="https://images2017.cnblogs.com/blog/486074/201711/486074-20171123160526915-1233965664.png" alt=""></strong></p><p>特点：异步批量队列，在队列到达指定长度，或者到达指定时间后，批量进行数据处理。适合于对响应时间要求低，能够容忍一定的数据丢失的场景。比如短小文本数据的批量保存。</p><p>在经过一段时间调研后，我们发现Disruptor更能满足我们需要。</p><p>首先介绍一下Disruptor的强悍的性能。</p><p><img src="https://images2017.cnblogs.com/blog/486074/201711/486074-20171123160549118-772353050.png" alt=""></p><p><img src="https://images2017.cnblogs.com/blog/486074/201711/486074-20171123160758571-551925328.png" alt=""></p><p><em><img src="https://images2017.cnblogs.com/blog/486074/201711/486074-20171123160602540-322185955.png" alt=""></em></p><p><img src="https://images2017.cnblogs.com/blog/486074/201711/486074-20171123160612540-1814206405.png" alt=""></p><p>这张图包含我列举的上述的异步队列模型景，因此很有代表意义。Disruptor因为使用无锁的队列方式，具有很高的性能。具体的原理不详述，大家可以搜索看到。Disruptor支持上面典型场景，并且灵活使用Disruptor的工作流机制，能简化编程。</p><blockquote><ul><li>英文文章入门：<a href="https://github.com/LMAX-Exchange/disruptor/wiki/Getting-Started" target="_blank" rel="noopener">https://github.com/LMAX-Exchange/disruptor/wiki/Getting-Started</a></li></ul><ul><li>中文的demo链接：<a href="http://my.oschina.net/u/2273085/blog/507735?p=1" target="_blank" rel="noopener">http://my.oschina.net/u/2273085/blog/507735?p=1</a></li></ul><ul><li>并发框架Disruptor相关译文：<a href="http://ifeve.com/disruptor/" target="_blank" rel="noopener">http://ifeve.com/disruptor/</a></li></ul></blockquote><p>再贴一下官方的测试结果。</p><p><img src="https://images2017.cnblogs.com/blog/486074/201711/486074-20171123160830040-140146429.png" alt=""></p><p>下面从代码层面说明disruptor的几种用法。</p><p><strong>使用Disruptor（单生产者多消费者）</strong></p><p><strong><img src="https://images2017.cnblogs.com/blog/486074/201711/486074-20171123160847211-658956502.png" alt=""></strong></p><p>Disruptor 提供了多个 WaitStrategy的实现，每种策略都具有不同性能和优缺点，根据实际运行环境的 CPU 的硬件特点选择恰当的策略，并配合特定的 JVM的配置参数，能够实现不同的性能提升。 例如，BlockingWaitStrategy、SleepingWaitStrategy、YieldingWaitStrategy 等，其中：</p><ul><li><p>BlockingWaitStrategy 是最低效的策略，但其对CPU的消耗最小并且在各种不同部署环境中能提供更加一致的性能表现；</p></li><li><p>SleepingWaitStrategy 的性能表现跟 BlockingWaitStrategy 差不多，对 CPU的消耗也类似，但其对生产者线程的影响最小，适合用于异步日志类似的场景；</p></li><li><p>YieldingWaitStrategy的性能是最好的，适合用于低延迟的系统。在要求极高性能且事件处理线数小于 CPU逻辑核心数的场景中，推荐使用此策略；例如，CPU开启超线程的特性。</p></li></ul><p>我们现在使用BlockingWaitStrategy这种模式。</p><p><strong>使用Disruptor（多生产者多消费者）</strong></p><p><strong><img src="https://images2017.cnblogs.com/blog/486074/201711/486074-20171123160900602-1899411962.png" alt=""></strong></p><p>使用Disruptor（多生产者多消费者）</p><p><img src="https://images2017.cnblogs.com/blog/486074/201711/486074-20171123160914665-743037908.png" alt=""></p><p>这个例子中，使用类似线程池的消费组处理数据。</p><p><strong>多步模式工作流：Disruptor</strong></p><p><strong><img src="https://images2017.cnblogs.com/blog/486074/201711/486074-20171123160932305-1430035066.png" alt=""></strong></p><p><img src="https://images2017.cnblogs.com/blog/486074/201711/486074-20171123160959430-520072022.png" alt=""></p><p>使用异步后的烦恼</p><p><strong>烦恼一： 数据丢失的风险</strong></p><p>解决方式：先写日志或数据库，后放入异步队列.</p><p><strong>烦恼二：对其他系统的压力变大</strong></p><p>解决方式：使用一定的限流和熔断，对其他系统进行保护。</p><p><strong>烦恼三：数据保存后异步任务未执行</strong></p><p>解决方式：使用异步任务补偿的方式，定期从数据库中获取数据，放到队列中进行执行，执行后更新数据状态位。</p><p><strong>烦恼四：怎样队列长设置和消费者数量</strong></p><p>解决方式：使用实际的压力测试来获得队列长度。或者使用排队论的数学公式得到初步的值,然后进行实际压测。</p><p><strong>最后介绍一下项目中的经验：</strong></p><ul><li><p>量力而行：根据业务特点进行技术选型，业务量小尽量避免使用异步。有所为，有所不为</p></li><li><p>数据说话：异步时一定要进行必要的压力测试</p></li><li><p>先找出系统的关键点：优化单体系统内的性能，再通过整体系统分解来全局优化</p></li><li><p>根据团队和项目的特点选择框架。</p></li></ul><p><a href="https://www.cnblogs.com/davidwang456/articles/6548394.html" target="_blank" rel="noopener">https://www.cnblogs.com/davidwang456/articles/6548394.html</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java高并发异步应用案例&quot;&gt;&lt;a href=&quot;#Java高并发异步应用案例&quot; class=&quot;headerlink&quot; title=&quot;Java高并发异步应用案例&quot;&gt;&lt;/a&gt;Java高并发异步应用案例&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;h1 id=&quot;Java高并发异步应用案
      
    
    </summary>
    
      <category term="02_code_language" scheme="https://30s.github.io/categories/02-code-language/"/>
    
      <category term="022_java" scheme="https://30s.github.io/categories/02-code-language/022-java/"/>
    
      <category term="0228_optimize" scheme="https://30s.github.io/categories/02-code-language/022-java/0228-optimize/"/>
    
    
      <category term="Code Language" scheme="https://30s.github.io/tags/Code-Language/"/>
    
      <category term="Java" scheme="https://30s.github.io/tags/Java/"/>
    
      <category term="Optimize" scheme="https://30s.github.io/tags/Optimize/"/>
    
      <category term="Asynchronous" scheme="https://30s.github.io/tags/Asynchronous/"/>
    
  </entry>
  
  <entry>
    <title>CGLIB(Code Generation Library)详解</title>
    <link href="https://30s.github.io/2010/09/01/02_code_language/022_java/0221_java_base/dynamic_proxy/cglib/CGLIB(Code%20Generation%20Library)%E8%AF%A6%E8%A7%A3/"/>
    <id>https://30s.github.io/2010/09/01/02_code_language/022_java/0221_java_base/dynamic_proxy/cglib/CGLIB(Code Generation Library)详解/</id>
    <published>2010-09-01T05:00:00.000Z</published>
    <updated>2018-03-07T14:42:00.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CGLIB-Code-Generation-Library-详解"><a href="#CGLIB-Code-Generation-Library-详解" class="headerlink" title="CGLIB(Code Generation Library)详解"></a>CGLIB(Code Generation Library)详解</h1><p><a href="http://blog.csdn.net/danchu/article/details/70238002" target="_blank" rel="noopener">http://blog.csdn.net/danchu/article/details/70238002</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CGLIB-Code-Generation-Library-详解&quot;&gt;&lt;a href=&quot;#CGLIB-Code-Generation-Library-详解&quot; class=&quot;headerlink&quot; title=&quot;CGLIB(Code Generation Librar
      
    
    </summary>
    
      <category term="02_code_language" scheme="https://30s.github.io/categories/02-code-language/"/>
    
      <category term="022_java" scheme="https://30s.github.io/categories/02-code-language/022-java/"/>
    
      <category term="0221_java_base" scheme="https://30s.github.io/categories/02-code-language/022-java/0221-java-base/"/>
    
    
      <category term="Code Language" scheme="https://30s.github.io/tags/Code-Language/"/>
    
      <category term="Java" scheme="https://30s.github.io/tags/Java/"/>
    
      <category term="Java Base" scheme="https://30s.github.io/tags/Java-Base/"/>
    
      <category term="CGLIB" scheme="https://30s.github.io/tags/CGLIB/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP十个入门问题</title>
    <link href="https://30s.github.io/2010/09/01/02_code_language/022_java/0225_net/tcp_ip/TCP%20IP%E5%8D%81%E4%B8%AA%E5%85%A5%E9%97%A8%E9%97%AE%E9%A2%98/"/>
    <id>https://30s.github.io/2010/09/01/02_code_language/022_java/0225_net/tcp_ip/TCP IP十个入门问题/</id>
    <published>2010-09-01T05:00:00.000Z</published>
    <updated>2018-03-12T21:02:11.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP-IP十个入门问题"><a href="#TCP-IP十个入门问题" class="headerlink" title="TCP IP十个入门问题"></a>TCP IP十个入门问题</h1><ul><li><p>本文整理了一些TCP/IP协议簇中需要必知必会的十大问题，既是面试高频问题，又是程序员必备基础素养。</p><p>1、TCP/IP模型</p><p>TCP/IP协议模型（Transmission Control Protocol/Internet Protocol），包含了一系列构成互联网基础的网络协议，是Internet的核心协议。</p><p>基于TCP/IP的参考模型将协议分成四个层次，它们分别是链路层、网络层、传输层和应用层。下图表示TCP/IP模型与OSI模型各层的对照关系。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20170915/a19f861043d9491eb7aa0874921202c7.jpeg" alt=""></p><p>TCP/IP协议族按照层次由上到下，层层包装。最上面的是应用层，这里面有http，ftp,等等我们熟悉的协议。而第二层则是传输层，著名的TCP和UDP协议就在这个层次。第三层是网络层，IP协议就在这里，它负责对数据加上IP地址和其他的数据以确定传输的目标。第四层是数据链路层，这个层次为待传送的数据加入一个以太网协议头，并进行CRC编码，为最后的数据传输做准备。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20170915/3ee2e26552b649d2893c4149acaadb9a.jpeg" alt=""></p><p>上图清楚地表示了TCP/IP协议中每个层的作用，而TCP/IP协议通信的过程其实就对应着数据入栈与出栈的过程。入栈的过程，数据发送方每层不断地封装首部与尾部，添加一些传输的信息，确保能传输到目的地。出栈的过程，数据接收方每层不断地拆除首部与尾部，得到最终传输的数据。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20170915/26f37e1988614ffa9eec5dcd6bed3fbd.jpeg" alt=""></p><p>上图以HTTP协议为例，具体说明。</p><p>2、数据链路层</p><p>物理层负责0、1比特流与物理设备电压高低、光的闪灭之间的互换。 数据链路层负责将0、1序列划分为数据帧从一个节点传输到临近的另一个节点,这些节点是通过MAC来唯一标识的(MAC,物理地址，一个主机会有一个MAC地址)。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20170915/5d5d36018c3248c78c7e18aab6374408.jpeg" alt=""></p><p>封装成帧: 把网络层数据报加头和尾，封装成帧,帧头中包括源MAC地址和目的MAC地址。</p><p>透明传输:零比特填充、转义字符。</p><p>可靠传输: 在出错率很低的链路上很少用，但是无线链路WLAN会保证可靠传输。</p><p>差错检测(CRC):接收者检测错误,如果发现差错，丢弃该帧。</p><p>3、网络层</p><blockquote><p><strong>1.IP协议</strong></p></blockquote><p>IP协议是TCP/IP协议的核心，所有的TCP，UDP，IMCP，IGMP的数据都以IP数据格式传输。要注意的是，IP不是可靠的协议，这是说，IP协议没有提供一种数据未传达以后的处理机制，这被认为是上层协议：TCP或UDP要做的事情。</p><blockquote><p><strong>1.1 IP地址</strong></p></blockquote><p>在数据链路层中我们一般通过MAC地址来识别不同的节点，而在IP层我们也要有一个类似的地址标识，这就是IP地址。</p><p>32位IP地址分为网络位和地址位，这样做可以减少路由器中路由表记录的数目，有了网络地址，就可以限定拥有相同网络地址的终端都在同一个范围内，那么路由表只需要维护一条这个网络地址的方向，就可以找到相应的这些终端了。</p><p>A类IP地址: 0.0.0.0~127.255.255.255</p><p>B类IP地址:128.0.0.0~191.255.255.255</p><p>C类IP地址:192.0.0.0~239.255.255.255</p><blockquote><p><strong>1.2 IP协议头</strong></p></blockquote><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20170915/7cce2dec445a4f4abf53b00657cdd49f.jpeg" alt=""></p><p>这里只介绍:八位的TTL字段。这个字段规定该数据包在穿过多少个路由之后才会被抛弃。某个IP数据包每穿过一个路由器，该数据包的TTL数值就会减少1，当该数据包的TTL成为零，它就会被自动抛弃。</p><p>这个字段的最大值也就是255，也就是说一个协议包也就在路由器里面穿行255次就会被抛弃了，根据系统的不同，这个数字也不一样，一般是32或者是64。</p><blockquote><p><strong>2.ARP及RARP协议</strong></p></blockquote><p>ARP 是根据IP地址获取MAC地址的一种协议。</p><p>ARP（地址解析）协议是一种解析协议，本来主机是完全不知道这个IP对应的是哪个主机的哪个接口，当主机要发送一个IP包的时候，会首先查一下自己的ARP高速缓存（就是一个IP-MAC地址对应表缓存）。</p><p>如果查询的IP－MAC值对不存在，那么主机就向网络发送一个ARP协议广播包，这个广播包里面就有待查询的IP地址，而直接收到这份广播的包的所有主机都会查询自己的IP地址，如果收到广播包的某一个主机发现自己符合条件，那么就准备好一个包含自己的MAC地址的ARP包传送给发送ARP广播的主机。</p><p>而广播主机拿到ARP包后会更新自己的ARP缓存（就是存放IP-MAC对应表的地方）。发送广播的主机就会用新的ARP缓存数据准备好数据链路层的的数据包发送工作。</p><p>RARP协议的工作与此相反，不做赘述。</p><blockquote><p><strong>3. ICMP协议</strong></p></blockquote><p>IP协议并不是一个可靠的协议，它不保证数据被送达，那么，自然的，保证数据送达的工作应该由其他的模块来完成。其中一个重要的模块就是ICMP(网络控制报文)协议。ICMP不是高层协议，而是IP层的协议。</p><p>当传送IP数据包发生错误。比如主机不可达，路由不可达等等，ICMP协议将会把错误信息封包，然后传送回给主机。给主机一个处理错误的机会，这 也就是为什么说建立在IP层以上的协议是可能做到安全的原因。</p><p><strong>4、ping</strong></p><p>ping可以说是ICMP的最著名的应用，是TCP/IP协议的一部分。利用“ping”命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。</p><p>例如：当我们某一个网站上不去的时候。通常会ping一下这个网站。ping会回显出一些有用的信息。一般的信息如下:</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20170915/b1e16087a8dc4a4bb7767f9c0ff5d4a3.jpeg" alt=""></p><p>ping这个单词源自声纳定位，而这个程序的作用也确实如此，它利用ICMP协议包来侦测另一个主机是否可达。原理是用类型码为0的ICMP发请 求，受到请求的主机则用类型码为8的ICMP回应。</p><p>ping程序来计算间隔时间，并计算有多少个包被送达。用户就可以判断网络大致的情况。我们可以看到， ping给出来了传送的时间和TTL的数据。</p><p>5、Traceroute</p><p>Traceroute是用来侦测主机到目的主机之间所经路由情况的重要工具，也是最便利的工具。</p><p>Traceroute的原理是非常非常的有意思，它收到到目的主机的IP后，首先给目的主机发送一个TTL=1的UDP数据包，而经过的第一个路由器收到这个数据包以后，就自动把TTL减1，而TTL变为0以后，路由器就把这个包给抛弃了，并同时产生 一个主机不可达的ICMP数据报给主机。主机收到这个数据报以后再发一个TTL=2的UDP数据报给目的主机，然后刺激第二个路由器给主机发ICMP数据 报。如此往复直到到达目的主机。这样，traceroute就拿到了所有的路由器IP。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20170915/89716babca8d4115969a4de61dffe28a.jpeg" alt=""></p><p>6、TCP/UDP</p><p>TCP/UDP都是是传输层协议，但是两者具有不同的特性，同时也具有不同的应用场景，下面以图表的形式对比分析。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20170915/edead750c5e9439f9989b5a4980611b3.jpeg" alt=""></p><p><strong>面向报文</strong></p><p>面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。</p><p><strong>面向字节流</strong></p><p>面向字节流的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。</p><p>关于拥塞控制，流量控制，是TCP的重点，后面讲解。</p><p>TCP和UDP协议的一些应用</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20170915/ed1288a413654b60a94fd8fb5fa2c767.jpeg" alt=""></p><p>什么时候应该使用TCP？</p><p>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。</p><p>什么时候应该使用UDP？</p><p>当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;TCP-IP十个入门问题&quot;&gt;&lt;a href=&quot;#TCP-IP十个入门问题&quot; class=&quot;headerlink&quot; title=&quot;TCP IP十个入门问题&quot;&gt;&lt;/a&gt;TCP IP十个入门问题&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;本文整理了一些TCP/IP协议簇中需要必知
      
    
    </summary>
    
      <category term="02_code_language" scheme="https://30s.github.io/categories/02-code-language/"/>
    
      <category term="022_java" scheme="https://30s.github.io/categories/02-code-language/022-java/"/>
    
      <category term="0225_net" scheme="https://30s.github.io/categories/02-code-language/022-java/0225-net/"/>
    
    
      <category term="Code Language" scheme="https://30s.github.io/tags/Code-Language/"/>
    
      <category term="TCP/IP" scheme="https://30s.github.io/tags/TCP-IP/"/>
    
      <category term="Java" scheme="https://30s.github.io/tags/Java/"/>
    
      <category term="NET" scheme="https://30s.github.io/tags/NET/"/>
    
  </entry>
  
  <entry>
    <title>Java开发知识库</title>
    <link href="https://30s.github.io/2010/09/01/02_code_language/022_java/0229_web_page/Java%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    <id>https://30s.github.io/2010/09/01/02_code_language/022_java/0229_web_page/Java开发知识库/</id>
    <published>2010-09-01T05:00:00.000Z</published>
    <updated>2018-03-12T22:14:25.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java开发知识库"><a href="#Java开发知识库" class="headerlink" title="Java开发知识库"></a>Java开发知识库</h1><ul><li>IBM开发社区 <a href="https://www.ibm.com/developerworks/cn/java/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java开发知识库&quot;&gt;&lt;a href=&quot;#Java开发知识库&quot; class=&quot;headerlink&quot; title=&quot;Java开发知识库&quot;&gt;&lt;/a&gt;Java开发知识库&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;IBM开发社区 &lt;a href=&quot;https://www.ibm.com
      
    
    </summary>
    
      <category term="02_code_language" scheme="https://30s.github.io/categories/02-code-language/"/>
    
      <category term="022_java" scheme="https://30s.github.io/categories/02-code-language/022-java/"/>
    
      <category term="0229_knowledge_base" scheme="https://30s.github.io/categories/02-code-language/022-java/0229-knowledge-base/"/>
    
    
      <category term="Code Language" scheme="https://30s.github.io/tags/Code-Language/"/>
    
      <category term="Java" scheme="https://30s.github.io/tags/Java/"/>
    
      <category term="Optimize" scheme="https://30s.github.io/tags/Optimize/"/>
    
      <category term="Knowledge Base" scheme="https://30s.github.io/tags/Knowledge-Base/"/>
    
  </entry>
  
  <entry>
    <title>定制并发类系列</title>
    <link href="https://30s.github.io/2010/09/01/02_code_language/022_java/0227_concurrent_package/%E5%AE%9A%E5%88%B6%E5%B9%B6%E5%8F%91%E7%B1%BB%E7%B3%BB%E5%88%97/"/>
    <id>https://30s.github.io/2010/09/01/02_code_language/022_java/0227_concurrent_package/定制并发类系列/</id>
    <published>2010-09-01T05:00:00.000Z</published>
    <updated>2018-03-12T22:12:58.812Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定制并发类系列"><a href="#定制并发类系列" class="headerlink" title="定制并发类系列"></a>定制并发类系列</h1><ul><li><p><strong>声明</strong>：本文是《 <a href="http://it-ebooks.info/book/1116/" target="_blank" rel="noopener">Java 7 Concurrency Cookbook</a> 》的第七章，作者： Javier Fernández González     译者：许巧辉 </p><p>在这个文章中，我们将包含：</p><ul><li><a href="http://ifeve.com/customizing-concurrency-classes-2/" title="定制并发类（二）定制ThreadPoolExecutor类" target="_blank" rel="noopener">定制ThreadPoolExecutor类</a></li><li><a href="http://ifeve.com/customizing-concurrency-classes-2/" title="定制并发类（二）定制ThreadPoolExecutor类" target="_blank" rel="noopener">实现一个基于优先级的Executor类</a></li><li><a href="http://ifeve.com/customizing-concurrency-classes-3/" title="定制并发类（三）实现一个基于优先级的Executor类" target="_blank" rel="noopener">实现ThreadFactory接口生成自定义的线程</a></li><li><a href="http://ifeve.com/customizing-concurrency-classes-4/" title="定制并发类（四）实现ThreadFactory接口生成自定义的线程" target="_blank" rel="noopener">在一个Executor对象中使用我们的ThreadFactory</a></li><li><a href="http://ifeve.com/customizing-concurrency-classes-5/" title="定制并发类（五）在一个Executor对象中使用我们的ThreadFactory" target="_blank" rel="noopener">定制任务运行在一个计划的线程池中</a></li><li><a href="http://ifeve.com/customizing-concurrency-classes-6/" title="定制并发类（六）自定义在计划的线程池内运行的任务" target="_blank" rel="noopener">实现ThreadFactory接口生成自定义的线程给Fork/Join框架</a></li><li><a href="http://ifeve.com/customizing-concurrency-classes-7/" title="定制并发类（七）实现ThreadFactory接口生成自定义的线程给Fork/Join框架" target="_blank" rel="noopener">定制任务运行在Fork/Join框架中</a></li><li><a href="http://ifeve.com/customizing-concurrency-classes-9/" title="定制并发类（九）实现一个自定义的Lock类" target="_blank" rel="noopener">实现一个自定义的Lock类</a></li><li><a href="http://ifeve.com/customizing-concurrency-classes-10/" title="定制并发类（十）实现一个基于优先级的转换队列" target="_blank" rel="noopener">实现一个基于优先级的传输队列</a></li><li><a href="http://ifeve.com/customizing-concurrency-classes-11/" title="定制并发类（十一）实现自定义的原子对象" target="_blank" rel="noopener">实现你自己的原子对象</a></li></ul><p><strong>引言</strong></p><p>Java 并发API提供许多接口和类来实现并发应用程序。它们提供底层（low-level）机制，如Thread类、Runnable或Callable接口、或synchronized关键字。同样也提供高级（high-level）机制，如Executor框架和Java 7 发布的Fork/Join框架。尽管这样，你可能发现你自己开发一个程序时，没有一个java类能满足你的需求。</p><p>在这种情况下，你也许需要基于Java提供的（API）实现自己定制的并发工具。基本上，你可以：</p><ul><li>实现一个接口提供那个接口定义的功能。比如：ThreadFactory接口。</li><li>覆盖一个类的一些方法来调整它的行为以满足你的需求。比如，覆盖Thread类的run()方法，默认情况下，它没有用并且应该被覆盖以提供一些功能。</li></ul><p>通过这个文章的指南，你将学习如何改变一些Java并发API类的行为，而不必从头开始设计一个并发框架。你可以使用这些指南作为初始点来实现你自己的定制。</p><p><a href="http://ifeve.com/customizing-concurrency-classes-1/" target="_blank" rel="noopener">http://ifeve.com/customizing-concurrency-classes-1/</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定制并发类系列&quot;&gt;&lt;a href=&quot;#定制并发类系列&quot; class=&quot;headerlink&quot; title=&quot;定制并发类系列&quot;&gt;&lt;/a&gt;定制并发类系列&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;声明&lt;/strong&gt;：本文是《 &lt;a href=&quot;http://
      
    
    </summary>
    
      <category term="02_code_language" scheme="https://30s.github.io/categories/02-code-language/"/>
    
      <category term="022_java" scheme="https://30s.github.io/categories/02-code-language/022-java/"/>
    
      <category term="0227_concurrent" scheme="https://30s.github.io/categories/02-code-language/022-java/0227-concurrent/"/>
    
    
      <category term="Code Language" scheme="https://30s.github.io/tags/Code-Language/"/>
    
      <category term="Java" scheme="https://30s.github.io/tags/Java/"/>
    
      <category term="Concurrent" scheme="https://30s.github.io/tags/Concurrent/"/>
    
  </entry>
  
  <entry>
    <title>Java网络编程：UDP DatagramSocket</title>
    <link href="https://30s.github.io/2010/09/01/02_code_language/022_java/0225_net/socket/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%9AUDP%20DatagramSocket/"/>
    <id>https://30s.github.io/2010/09/01/02_code_language/022_java/0225_net/socket/Java网络编程：UDP DatagramSocket/</id>
    <published>2010-09-01T05:00:00.000Z</published>
    <updated>2018-03-12T20:59:58.840Z</updated>
    
    <content type="html"><![CDATA[<ul><li><h3 id="Java网络编程：UDP-DatagramSocket"><a href="#Java网络编程：UDP-DatagramSocket" class="headerlink" title="Java网络编程：UDP DatagramSocket"></a>Java网络编程：UDP DatagramSocket</h3><p><a href="http://tutorials.jenkov.com/java-networking/udp-datagram-sockets.html" target="_blank" rel="noopener">原文地址</a></p><p>DatagramSocket类是java通过UDP通信的途径。UDP仍位于IP层的上面。 你可以用DatagramSocket类发送和接收UDP数据包。</p><p><strong>UDP 和TCP</strong></p><p>UDP工作方式和TCP有点不同。当你通过TCP发送数据时，你先要创建连接。一旦TCP连接建立了，TCP会保证你的数据传递到对端，否则它将告诉你已发生的错误。</p><p>仅仅用UDP来发送数据包（datagrams）到网络间的某个IP地址。你不能保证数据会不会到达。你也不能保证UDP数据包到达接收方的指令。这意味着UDP比TCP有更少的协议开销（无完整检查流）。</p><p>当数据传输过程中不在乎数据包是否丢失时，UDP就比较适合这样的数据传输。比如，网上的电视信号的传输。你希望信号到达客户端时尽可能地接近直播。因此，如果丢失一两个画面，你一点都不在乎。你不希望直播延迟，值想确保所有的画面显示在客户端。你宁可跳过丢失的画面，希望一直看到最新的画面。</p><p>这种情况也会发生在网上摄像机直播节目中。谁会关心过去发生的什么，你只想显示当前的画面。你不希望比实际情况慢30s结束，只因为你想看到摄像机显示给观众的所有画面。这跟摄像机录像有点不同。从摄像机录制画面到磁盘，你不希望丢失一个画面。你可能还希望有点延迟，如果有重大的情况发生，就不需要倒回去检查画面。</p><h3 id="通过DatagramSocket发送数据"><a href="#通过DatagramSocket发送数据" class="headerlink" title="通过DatagramSocket发送数据"></a><strong>通过DatagramSocket发送数据</strong></h3><p>通过Java的DatagramSocket类发送数据，首先需要创建DatagramPacket。如下：</p><p>buffer = new byte[65508];<br>InetAddress address = new DatagramPacket(buffer, buffer.length, address,9000);</p><p>字节缓冲块（字节数组）就是UDP数据包中用来发送的数据。缓冲块上限长度为65508字节，是单一UDP数据包发送的最大的数据量。</p><p>数据包构造函数的长度就是缓存块中用于发送的数据的长度。所有多于最大容量的数据都会被忽略。</p><p>包含节点（例如服务器）地址的InetAddress实例携带节点（如服务器）的地址发送的UDP数据包。InetAddress类表示一个ip地址（网络地址）。getByName()方法返回带有一个InetAddress实例，该实例带有匹配主机名的ip地址。</p><p>端口参数是UDP端口服务器用来接收正在监听的数据。UDP端口和TCP端口是不一样的。一台电脑同时有不同的进程监听UDP和TCP 80端口。</p><p>为了发送数据包，你需要创建DatagramSocket来发送数据。如下：</p><p>DatagramSocketdatagramSocket = new DatagramSocket();</p><p>调用send()方法发送数据，像这样：</p><p>datagramSocket.send(packet);</p><p>完整示例：</p><p>DatagramSocketdatagramSocket = new DatagramSocket();<br>byte [] buffer = “0123456789”.getBytes();<br>InetAddressreceiverAddress = InetAddress.getLocalHost();<br>DataframPacket packet =<code></code>new<code></code>DatagramPacket( buffer, buffer.length, receiverAddress, 80);<br>datagramSocket.send(packet);</p><h3 id="从DatagramSocket获取数据"><a href="#从DatagramSocket获取数据" class="headerlink" title="从DatagramSocket获取数据"></a><strong>从DatagramSocket获取数据</strong></h3><p>从DataframSocket获取数据时，首先创建DataframPacket,然后通过DatagramSocket类的receive()方法接收数据。例如：<br>DatagramSocketdatagramSocket = new DatagramSocket(80);<br>yte [] buffer = new byte [10];<br>DatagramPacket packet = new DatagramPacket(buffer, buffer.length);<br>datagramSocket.receive(packet);</p><p>注意DatagramSocket是如何通过传递参数80到它的构造器初始化的。这个参数是UDP端口的DatagramSocket用来接收UDP数据包的。像之前提到的，TCP和UDP端口是不一样的，也不重叠。你可以有俩个不同的进程同时在端口80监听TCP和UDP，没有任何冲突。</p><p>第二，字节缓存块和DatagramPacket创建了。注意DatagramPacket是没有关于节点如何发送数据的信息的，当创建一个方数据的DatagramPacket时，它会直到这个信息。这就是为什么我们会用DatagramPacket接收数据而不是发送数据。因此没有目标地址是必须的。</p><p>最后，调用DatagramSocket的receive()方法。直到数据包接收到为止，这个方法都是阻塞的。</p><p>接收的数据位于DatagramPacket的字节缓冲块。缓冲块可以通过调用getData()获得：</p><p>byte [] buffer = packet.getData();</p><p>缓冲块接收了多少的数据需要你去找出来。你用的协议应该定义每个UDP包发多少数据，活着定义一个你能找到的数据结束标记。<br>一个真正的服务端程序可能会在一个loop中调用receive()方法，传送所有接收到的DatagramPacket到工作的线程池中，就像TCP服务器处理请求连接一样（查看<a href="http://tutorials.jenkov.com/java-multithreaded-servers/index.html" target="_blank" rel="noopener">Java Multithreaded Servers</a>获取更多详情）</p><p><a href="http://ifeve.com/java-udp-datagramsocket/" target="_blank" rel="noopener">http://ifeve.com/java-udp-datagramsocket/</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;h3 id=&quot;Java网络编程：UDP-DatagramSocket&quot;&gt;&lt;a href=&quot;#Java网络编程：UDP-DatagramSocket&quot; class=&quot;headerlink&quot; title=&quot;Java网络编程：UDP DatagramSocket&quot;&gt;
      
    
    </summary>
    
      <category term="02_code_language" scheme="https://30s.github.io/categories/02-code-language/"/>
    
      <category term="022_java" scheme="https://30s.github.io/categories/02-code-language/022-java/"/>
    
      <category term="0225_net" scheme="https://30s.github.io/categories/02-code-language/022-java/0225-net/"/>
    
    
      <category term="Code Language" scheme="https://30s.github.io/tags/Code-Language/"/>
    
      <category term="Java" scheme="https://30s.github.io/tags/Java/"/>
    
      <category term="NET" scheme="https://30s.github.io/tags/NET/"/>
    
      <category term="Socket" scheme="https://30s.github.io/tags/Socket/"/>
    
  </entry>
  
</feed>
